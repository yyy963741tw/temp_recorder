/***************************************************************************//**
 * @file   ltc298x.c
 * @brief  Implementation of the refactored, datasheet-driven LTC298x Driver.
 * @author (Generated by Gemini based on user request and datasheet)
 * @details This driver is cleanly architected around the ltc298x_dev struct
 * and uses an init_param struct for clear, robust initialization.
 *******************************************************************************/
#include "ltc298x.h"
#include "../../../Inc/comm.h" // For HAL_Delay and GPIO macros
#include <string.h>         // For memcpy, memset

/******************************************************************************/
/********************* LOCAL FUNCTION PROTOTYPES ******************************/
/******************************************************************************/
static void ltc298x_cs_set(ltc298x_dev *device, int value);
int32_t ltc298x_spi_rw(ltc298x_dev *dev, uint8_t cmd, uint16_t addr, uint8_t *data, uint16_t len);
static uint32_t build_channel_word(const struct ltc2983_sensor *sensor);

/******************************************************************************/
/************************** FUNCTIONS DEFINITION ******************************/
/******************************************************************************/

/**
 * @brief Internal static function to control the CS pin based on the device struct.
 */
static void ltc298x_cs_set(ltc298x_dev *device, int value) {
	if (!device) return;
	switch(device->cs_idx){
	case 1:
		LTC298X_CS1(value);
		break;
	case 2:
		LTC298X_CS2(value);
		break;
	case 3:
		LTC298X_CS3(value);
		break;
	case 4:
//		LTC298X_CS4(value);
		break;
		// Add other cases for different CS pins if needed
	default:
		break;
	}
}

/**
 * @brief Low-level SPI transfer function for the LTC298x.
 */
int32_t ltc298x_spi_rw(ltc298x_dev *dev, uint8_t cmd, uint16_t addr, uint8_t *data, uint16_t len)
{
	uint8_t tx_buffer[260];
	uint8_t rx_buffer[260];
	if (3 + len > sizeof(tx_buffer)) return -1; // Request too large

	tx_buffer[0] = cmd;
	tx_buffer[1] = (addr >> 8) & 0xFF;
	tx_buffer[2] = addr & 0xFF;

	if (cmd == LTC298X_SPI_WRITE_BYTE) {
		memcpy(&tx_buffer[3], data, len);
	} else {
		memset(&tx_buffer[3], 0, len); // Dummy bytes for read
	}

	ltc298x_cs_set(dev, 0); // Assert CS
	int fail = SPIM_TransBlocking_n(dev->spi_idx, tx_buffer, rx_buffer, 3 + len);
	ltc298x_cs_set(dev, 1); // De-assert CS

	if (!fail && cmd == LTC298X_SPI_READ_BYTE) {
		memcpy(data, &rx_buffer[3], len);
	}
	return fail;
}

/**
 * @brief Main initialization function, matching the new architecture.
 */
int ltc298x_init(ltc298x_dev *device, const struct ltc298x_init_param *init_param)
{
	if (!device || !init_param || !init_param->sensors) return -1;

	// 1. Copy parameters from init_param to the device instance
	device->spi_idx = init_param->spi_idx;
	device->cs_idx = init_param->cs_idx;
	device->sensors = init_param->sensors;

	switch (init_param->dev_id) {
	case ID_LTC2983:
		device->max_channels = 20;
		break;
	case ID_LTC2986:
		device->max_channels = 10; // 告訴驅動，最大通道數是 10
		break;
	default: return -1;
	}

	// 2. Hardware Reset & Startup Delay
	LTC298X_RESET(0);
	HAL_Delay(10);
	LTC298X_RESET(1);
	HAL_Delay(250); // Datasheet: 200ms max startup time

	// 3. Wait for Device Ready
	uint8_t status;
	uint32_t timeout = 100;
	do {
		if (ltc298x_spi_rw(device, LTC298X_SPI_READ_BYTE, LTC298X_STATUS_REG, &status, 1) != 0) return -2;
		if (LTC298X_STATUS_IS_DONE(status)) break;
		HAL_Delay(25);
	} while (--timeout);

	if (timeout == 0) return -3;

	// 4. Configure all assigned sensor channels
	for (int i = 0; i < device->max_channels; ++i) {
		if (device->sensors[i]) {
			uint32_t channel_word = build_channel_word(device->sensors[i]);
			if (channel_word != 0) {
				uint8_t buffer[4];
				buffer[0] = (channel_word >> 24) & 0xFF;
				buffer[1] = (channel_word >> 16) & 0xFF;
				buffer[2] = (channel_word >> 8) & 0xFF;
				buffer[3] = channel_word & 0xFF;
				if (ltc298x_spi_rw(device, LTC298X_SPI_WRITE_BYTE, LTC298X_CHAN_START_ADDR(device->sensors[i]->chan), buffer, 4) != 0) {
					return -4;
				}
			}
		}
	}
	return 0; // Success
}

/**
 * @brief Performs a complete blocking temperature measurement on a single channel.
 */
int ltc298x_read_channel_temp(ltc298x_dev *device, uint8_t channel, float *temperature)
{
	if (!device || !temperature || channel == 0 || channel > device->max_channels)
		return -1;

	// 1. Start Conversion
	uint8_t command = LTC298X_STATUS_START_CONVERSION | channel;
	if (ltc298x_spi_rw(device, LTC298X_SPI_WRITE_BYTE, LTC298X_STATUS_REG, &command, 1) != 0)
		return -2;

	// 2. Wait for Conversion to Complete
	uint8_t status;
	uint32_t timeout = 20; // 500ms timeout
	do {
		HAL_Delay(25);
		if (ltc298x_spi_rw(device, LTC298X_SPI_READ_BYTE, LTC298X_STATUS_REG, &status, 1) != 0) return -2;
		if (LTC298X_STATUS_IS_DONE(status)) break;
	} while (--timeout);

	if (timeout == 0)
		return -3;

	// 3. Read and Validate Result
	uint8_t result_buffer[4];
	if (ltc298x_spi_rw(device, LTC298X_SPI_READ_BYTE, LTC298X_CHAN_RES_ADDR(channel), result_buffer, 4) != 0)
		return -2;

	uint32_t raw_val = ((uint32_t)result_buffer[0] << 24) | ((uint32_t)result_buffer[1] << 16) | ((uint32_t)result_buffer[2] << 8) | result_buffer[3];
	if (!(raw_val & LTC298X_RESULT_VALID_BIT) || (raw_val & LTC298X_RESULT_HARD_FAULT_MASK))
		return -4;

	int32_t signed_data = raw_val & 0xFFFFFF;
	if (signed_data & 0x800000) signed_data |= 0xFF000000;

	*temperature = (float)signed_data / 1024.0f;

	return 0; // Success
}
///**
// * @brief Iterates through LTC devices and reads all their sensors with optimization.
// */
//int LTC2983_ReadMultipleTemperatures(ltc2983_device_manager devices[], unsigned char num_devices_to_find, unsigned char array_size)
//{
//    if (!devices || num_devices_to_find == 0) {
//        return 0; // 沒有東西需要讀取
//    }
//
//    unsigned char found_count = 0; // 用於計數已找到的有效設備
//
//    // 遍歷所有指定的 LTC2983 設備，最多遍歷 array_size 次
//    for (int i = 0; i < array_size; i++) {
//        ltc2983_device_manager *current_ltc = &devices[i];
//
//        // 透過檢查 dev_instance 的 spi_idx 是否被初始化過來判斷設備是否有效
//        // 這樣可以安全地跳過稀疏陣列中未設定的成員
//        if (current_ltc->dev_instance.spi_idx != 0) {
//            found_count++; // 找到一個有效設備，計數器加 1
//
//            // --- 開始讀取這個設備的所有通道 ---
//            for (int ch_idx = 0; ch_idx < 20; ch_idx++) {
//                if (current_ltc->sensors[ch_idx] != NULL) {
//                    int read_status = ltc298x_read_channel_temp(
//                        &current_ltc->dev_instance,
//                        ch_idx + 1,
//                        &current_ltc->temperatures[ch_idx]
//                    );
//
//                    if (read_status != 0) {
//                        current_ltc->temperatures[ch_idx] = -999.0f;
//                    }
//                    HAL_Delay(100);
//                }
//            }
//            // --- 讀取完畢 ---
//
//            // 如果已找到的數量達到了我們的目標，就提前結束外層迴圈
//            if (found_count >= num_devices_to_find) {
//                break;
//            }
//        }
//    }
//    return 0; // 所有讀取成功完成
//}
/**
 * @brief Helper to build the 32-bit channel assignment word.
 */
static uint32_t build_channel_word(const struct ltc2983_sensor *sensor) {
	uint32_t word = 0;
	word |= ((uint32_t)sensor->type << 27);

	switch (sensor->type) {
	case LTC2983_THERMOCOUPLE_K: // And other TCs
	{
		const struct ltc2983_thermocouple *tc = (const struct ltc2983_thermocouple *)sensor;
		word |= ((uint32_t)tc->cold_junction_chan << 22);
		word |= ((uint32_t)tc->sensor_config << 18);
	}
	break;
	case LTC2983_DIODE:
	{
		const struct ltc2983_diode *diode = (const struct ltc2983_diode *)sensor;
		word |= ((uint32_t)diode->sensor_config << 24);
		word |= ((uint32_t)diode->excitation_current << 22);
	}
	break;
	// Add cases for other sensor types (RTD, Thermistor, etc.)
	default:
		break;
	}
	return word;
}

/**
 * @brief Writes a single byte to a register. (For testing)
 */
int32_t ltc298x_write_reg(ltc298x_dev *device, uint16_t addr, uint8_t data)
{
	if (!device) return -1;
	// We call the internal SPI function to perform the write operation.
	return ltc298x_spi_rw(device, LTC298X_SPI_WRITE_BYTE, addr, &data, 1);
}

/**
 * @brief Reads a single byte from a register. (For testing)
 */
int32_t ltc298x_read_reg(ltc298x_dev *device, uint16_t addr, uint8_t *data)
{
	if (!device || !data) return -1;
	// We call the internal SPI function to perform the read operation.
	return ltc298x_spi_rw(device, LTC298X_SPI_READ_BYTE, addr, data, 1);
}


/**
 * @brief 對一個已初始化的 LTC298x 裝置執行 SPI 讀寫測試。
 */
int LTC2986_TestReadWrite(ltc298x_dev *device)
{
	int ret;
	uint8_t write_val = 0xA5; // 任意測試值
	uint8_t read_val = 0x00;
	// 使用 MUX 延遲寄存器 (0x0FF) 進行測試，因為它是一個可讀寫的寄存器
	uint16_t test_reg = LTC298X_MUX_CONFIG_REG;

	// 1. 檢查傳入的指標是否有效
	if (device == NULL) {
		return -1; // 無效的裝置指標
	}

	// 假設初始化已完成，直接進行讀寫操作

	// 2. 寫入一個測試值到寄存器
	ret = ltc298x_write_reg(device, test_reg, write_val);
	if (ret != 0) {
		// SPI 寫入失敗
		return -2;
	}

	// 3. 從同一個寄存器讀取值
	ret = ltc298x_read_reg(device, test_reg, &read_val);
	if (ret != 0) {
		// SPI 讀取失敗
		return -3;
	}

	// 4. 比對寫入和讀取的值
	if (read_val == write_val) {
		// 測試成功
		return 0;
	} else {
		// 讀寫的值不匹配
		return -4;
	}
}

// --- 使用 ltc298x_spi_rw 進行多筆資料讀寫測試 ---
int LTC2986_TestMultiReadWrite(ltc298x_dev *device)
{
	int ret;
	const uint16_t test_addr = LTC298X_CHAN_ASSIGN_START_REG; // 測試位址 0x200
	const uint8_t data_len = 8; // 測試 8 個位元組

	uint8_t tx_data[8] = {0x01, 0x02, 0x03, 0x04, 0xAA, 0xBB, 0xCC, 0xDD};
	uint8_t rx_data[8];
	memset(rx_data, 0, sizeof(rx_data));

	if (device == NULL) {
		return -1;
	}

	// 2. 直接呼叫 ltc298x_spi_rw 寫入資料
	ret = ltc298x_spi_rw(device, LTC298X_SPI_WRITE_BYTE, test_addr, tx_data, data_len);
	if (ret != 0) {
		return -2; // 寫入失敗
	}

	// 3. 直接呼叫 ltc298x_spi_rw 讀取資料
	ret = ltc298x_spi_rw(device, LTC298X_SPI_READ_BYTE, test_addr, rx_data, data_len);
	if (ret != 0) {
		return -3; // 讀取失敗
	}

	// 4. 比對資料
	if (memcmp(tx_data, rx_data, data_len) == 0) {
		return 0; // 測試成功
	} else {
		return -4; // 資料不匹配
	}
}
