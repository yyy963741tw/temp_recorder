/***************************************************************************//**
 * @file   ltc298x.h
 * @brief  Final, complete, and refactored header for the LTC298x Driver.
 * @author (Generated by Gemini based on user request and datasheet)
 * @details This driver is cleanly architected around the ltc298x_dev struct
 * and uses an init_param struct for clear, robust initialization. This file
 * contains all necessary type and macro definitions.
*******************************************************************************/

#ifndef __LTC298X_H__
#define __LTC298X_H__

#include <stdint.h>
#include <stdbool.h>
#include <errno.h>
#include "../SPI_Master/SPI_Master.h"
#include "LTC298x_comm.h"

// NOTE: LTC298x_comm.h is NOT included here to prevent circular dependencies.
// It should be included by .c files that define or use the sensor instances.

// --- Datasheet References: Table 2A. Memory Map (Page 14) ---
#define LTC298X_STATUS_REG                      0x0000
#define LTC298X_TEMP_RES_START_REG              0x0010
#define LTC298X_CHAN_ASSIGN_START_REG           0x0200
#define LTC298X_GLOBAL_CONFIG_REG               0x00F0
#define LTC298X_MUX_CONFIG_REG                  0x00FF

// --- Datasheet Reference: Table 2B. SPI Instruction Byte (Page 14) ---
#define LTC298X_SPI_READ_BYTE                   0x03
#define LTC298X_SPI_WRITE_BYTE                  0x02

// -- Address Calculation Macros --
#define LTC298X_CHAN_START_ADDR(chan)           (((chan - 1) * 4) + LTC298X_CHAN_ASSIGN_START_REG)
#define LTC298X_CHAN_RES_ADDR(chan)             (((chan - 1) * 4) + LTC298X_TEMP_RES_START_REG)

// --- Datasheet Reference: Status Register (Page 16, 18, 19) ---
#define LTC298X_STATUS_START_CONVERSION         0x80
#define LTC298X_STATUS_DONE_BIT                 (1 << 6)
#define LTC298X_STATUS_IS_DONE(reg)             (((reg) & LTC298X_STATUS_DONE_BIT) != 0)

// --- Datasheet Reference: Conversion Result Word (Page 20) ---
#define LTC298X_RESULT_VALID_BIT                (1UL << 24)
#define LTC298X_RESULT_HARD_FAULT_MASK          (0xE0000000) // Sensor, ADC, or CJ hard fault

// =============================================================
//  LTC2983 Datasheet Configuration Masks
// =============================================================

// --- Thermocouple (Table 6, Page 32) ---
// Bit 26: Single-Ended (1=SE, 0=Differential)
#define TC_SINGLE_ENDED         (1UL << 26)
// Bit 23: Open Circuit Detect (1=Enable)
#define TC_OPEN_CKT_DETECT      (1UL << 23)
// Bits 25-24: Open Circuit Current (00=10uA, 01=100uA, 10=500uA, 11=1mA)
#define TC_OC_CURRENT_10UA      (0UL << 24)
#define TC_OC_CURRENT_100UA     (1UL << 24)

// --- Diode (Table 8, Page 36) ---
// Bit 26: Single-Ended (1=SE, 0=Differential)
#define DIODE_SINGLE_ENDED      (1UL << 26)
// Bit 25: 3-Reading Mode (1=Enable, Removes Series R errors)
#define DIODE_3_READING         (1UL << 25)
// Bit 24: Average (1=Enable, reduces noise)
#define DIODE_AVERAGE           (1UL << 24)
// Bits 23-22: Excitation Current (00=10uA, 01=20uA, 10=40uA, 11=80uA)
// 注意：如果您的 driver struct 有獨立的 excitation_current 欄位，這部分可能不需要在 config 裡設定
#define DIODE_CURRENT_20UA      (1UL << 22)

// --- RTD (Table 13, Page 43) ---
// Bits 21-20: Num Wires (00=2-wire, 01=3-wire, 10=4-wire, 11=4-wire Kelvin)
#define RTD_2_WIRE              (0UL << 20)
#define RTD_3_WIRE              (1UL << 20)
#define RTD_4_WIRE              (2UL << 20)
// Bits 19-18: Excitation Mode (00=No Rotation, 01=No Rotation/Sharing)
#define RTD_NO_ROTATION         (0UL << 18)
// Bits 17-14: Excitation Current (Example: 0010=10uA, 1000=500uA)
// 這裡的值需要依照阻值選擇，PT100 通常選大一點的電流 (如 100uA 或 500uA)
#define RTD_CURRENT_100UA       (0b0110UL << 14)
#define RTD_CURRENT_500UA       (0b1000UL << 14)
// Bits 13-12: Curve (00=European, 01=American, 10=Japanese, 11=ITS-90)
#define RTD_CURVE_EUROPEAN      (0UL << 12)


/******************************************************************************/
/*************************** TYPE DEFINITIONS *********************************/
/******************************************************************************/

enum ltc298x_id { ID_LTC2983, ID_LTC2984, ID_LTC2986 };
enum ltc2983_filter_notch_freq { LTC2983_50_60HZ_REJECTION, LTC2983_60HZ_REJECTION, LTC2983_50HZ_REJECTION };

// --- Datasheet Reference: Table 5. Sensor Type Selection (Page 18) ---
// This version uses the naming convention consistent with your LTC298x_comm.c file.
enum ltc2983_sensor_type {
    LTC2983_UNASSIGNED                          = 0,
    LTC2983_THERMOCOUPLE_J                      = 1,
    LTC2983_THERMOCOUPLE_K                      = 2,
    LTC2983_THERMOCOUPLE_E                      = 3,
    LTC2983_THERMOCOUPLE_N                      = 4,
    LTC2983_THERMOCOUPLE_R                      = 5,
    LTC2983_THERMOCOUPLE_S                      = 6,
    LTC2983_THERMOCOUPLE_T                      = 7,
    LTC2983_THERMOCOUPLE_B                      = 8,
    LTC2983_THERMOCOUPLE_CUSTOM                 = 9,
    LTC2983_RTD_PT_10                           = 10,
    LTC2983_RTD_PT_50                           = 11,
    LTC2983_RTD_PT_100                          = 12,
    LTC2983_RTD_PT_200                          = 13,
    LTC2983_RTD_PT_500                          = 14,
    LTC2983_RTD_PT_1000                         = 15,
    LTC2983_RTD_1000_375                        = 16,
    LTC2983_RTD_NI_120                          = 17,
    LTC2983_RTD_CUSTOM                          = 18,
    LTC2983_THERMISTOR_44004_2_252K              = 19,
    LTC2983_THERMISTOR_44005_3K                 = 20,
    LTC2983_THERMISTOR_44007_5K                 = 21,
    LTC2983_THERMISTOR_44006_10K                = 22,
    LTC2983_THERMISTOR_44008_30K                = 23,
    LTC2983_THERMISTOR_YSI_400_2_252K           = 24,
    LTC2983_THERMISTOR_SPECTRUM_1003_1K         = 25,
    LTC2983_THERMISTOR_CUSTOM_STEINHART_HART    = 26,
    LTC2983_THERMISTOR_CUSTOM_TABLE             = 27,
    LTC2983_DIODE                               = 28,
    LTC2983_RSENSE                              = 29,
    LTC2983_DIRECT_ADC                          = 30
};

// Base structure for any sensor
struct ltc2983_sensor {
	uint8_t chan;
	enum ltc2983_sensor_type type;
};

// Thermocouple sensor configuration
struct ltc2983_thermocouple {
	struct ltc2983_sensor sensor;
	uint32_t sensor_config;
	uint32_t cold_junction_chan;
};

// Diode sensor configuration
struct ltc2983_diode {
	struct ltc2983_sensor sensor;
	uint32_t sensor_config;
	uint32_t excitation_current;
};

/**
 * @brief Main driver instance structure. This holds the state of the device.
 */
typedef struct {
    SPIM_IDX spi_idx;
    int cs_idx;
    uint8_t max_channels;
    struct ltc2983_sensor **sensors; // Pointer to the user's sensor array
} ltc298x_dev;

/**
 * @brief Initialization parameter structure.
 * This structure is used to pass all necessary settings to the init function.
 */
struct ltc298x_init_param {
    enum ltc298x_id dev_id;
    SPIM_IDX spi_idx;
    int cs_idx;
    enum ltc2983_filter_notch_freq filter_freq;
    uint32_t mux_delay_us;
    struct ltc2983_sensor **sensors; // Pointer to the user-provided array of sensor pointers
};

// 將每個 LTC2983 晶片的資源打包成一個結構
typedef struct {
    ltc298x_dev dev_instance;         // LTC298x 驅動程式實例
    struct ltc2983_sensor *sensors[20]; // 該晶片對應的感測器設定
    unsigned char num_sensors;          // 實際使用的感測器數量
    float temperatures[20];               // 新增：存放該晶片所有通道的溫度讀值 (單位: °C)
} ltc2983_device_manager;

/******************************************************************************/
/*************************** FUNCTIONS DECLARATIONS ***************************/
/******************************************************************************/

/**
 * @brief Initializes the LTC298x device.
 * @param device - Pointer to the driver instance structure to be initialized.
 * @param init_param - Pointer to the initialization parameters structure.
 * @return 0 on success, negative error code on failure.
 */
int ltc298x_init(ltc298x_dev *device, const struct ltc298x_init_param *init_param);

/**
 * @brief Performs a complete blocking temperature measurement on a single channel.
 * @param device - Pointer to the initialized device instance.
 * @param channel - The channel number to measure (e.g., 9 for CH9).
 * @param temperature - Pointer to a float where the final temperature in °C will be stored.
 * @return 0 on success, negative error code on failure.
 */
int ltc298x_read_channel_temp(ltc298x_dev *device, uint8_t channel, float *temperature);


/**
 * @brief Iterates through an array of LTC2983 devices up to a maximum size,
 * reading all configured sensors until a target number of devices is found.
 * @param devices - An array of ltc2983_device_manager instances.
 * @param num_devices_to_find - The target number of active devices to find and process.
 * @param array_size - The total size of the devices array to iterate through (e.g., MAX_LTC2983_DEVICES).
 * @return 0 on success, or a negative error code if any read operation fails.
 */
//GO TO API
//int LTC2983_ReadMultipleTemperatures(ltc2983_device_manager devices[], unsigned char num_devices_to_find, unsigned char array_size);


/**
 * @brief Writes a single byte to a register. (For testing)
 * @param device - Pointer to the initialized device instance.
 * @param addr - The 16-bit register address.
 * @param data - The byte to write.
 * @return 0 on success, non-zero on failure.
 */
int32_t ltc298x_write_reg(ltc298x_dev *device, uint16_t addr, uint8_t data);

/**
 * @brief Reads a single byte from a register. (For testing)
 * @param device - Pointer to the initialized device instance.
 * @param addr - The 16-bit register address.
 * @param data - Pointer to a byte to store the read data.
 * @return 0 on success, non-zero on failure.
 */
int32_t ltc298x_read_reg(ltc298x_dev *device, uint16_t addr, uint8_t *data);

/**
 * @brief 執行 LTC2986 的 SPI 讀寫測試。
 *
 * 對 MUX 配置延遲寄存器 (0x00FF) 進行寫入，然後再讀取出來，
 * 最後比對寫入與讀取的值是否一致。
 *
 * @return int
 * - 0: 測試成功 (讀取的值與寫入的值相符)。
 * - -1: 初始化失敗。
 * - -2: 寫入 SPI 寄存器失敗。
 * - -3: 讀取 SPI 寄存器失敗。
 * - -4: 測試失敗 (讀取的值與寫入的值不符)。
 */
int LTC2986_TestReadWrite(ltc298x_dev *device);
/**
 * @brief 對一個已初始化的 LTC298x 裝置執行 SPI 多筆連續資料讀寫測試。
 *
 * 這個函數會對 LTC2986 的通道分配記憶體區塊 (從 0x200 開始)
 * 寫入 8 個位元組的資料，然後再讀回並進行比對。
 *
 * @param device 指向一個已經初始化完成的 ltc298x_dev 結構實例的指標。
 * @return int
 * - 0: 測試成功。
 * - -1: 傳入的 device 指標為 NULL。
 * - -2: 寫入多筆資料失敗。
 * - -3: 讀取多筆資料失敗。
 * - -4: 測試失敗 (讀回的資料與寫入的資料不符)。
 */
int LTC2986_TestMultiReadWrite(ltc298x_dev *device);
int32_t ltc298x_spi_rw(ltc298x_dev *dev, uint8_t cmd, uint16_t addr, uint8_t *data, uint16_t len);

#endif // __LTC298X_H__
