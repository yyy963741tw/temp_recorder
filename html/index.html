<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>STM32 æº«åº¦ç›£æ§å„€è¡¨æ¿ V52 (Fixed Address Logic)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-body: #f4f6f9;
            --bg-container: #ffffff;
            --bg-control: #f8f9fa;
            --border-color: #e9ecef;
            --text-main: #212529;
            --text-sub: #6c757d;
            --header-bg: #f1f3f5;
            --header-hover: #e9ecef;
            --box-shadow: rgba(0,0,0,0.1);
            --error-bg: #f8d7da;
            --error-text: #721c24;
            --error-border: #f5c6cb;
        }
        
        body.dark-mode {
            --bg-body: #121212;
            --bg-container: #1e1e1e;
            --bg-control: #2d2d2d;
            --border-color: #444;
            --text-main: #e0e0e0;
            --text-sub: #a0a0a0;
            --header-bg: #333;
            --header-hover: #444;
            --box-shadow: rgba(0,0,0,0.5);
            --error-bg: #441c1f;
            --error-text: #ea868f;
            --error-border: #6a2a30;
        }

        body { font-family: 'Segoe UI', sans-serif; background: var(--bg-body); color: var(--text-main); padding: 20px; transition: background 0.3s, color 0.3s; }
        .container { max-width: 98%; margin: 0 auto; background: var(--bg-container); padding: 25px; border-radius: 12px; box-shadow: 0 4px 15px var(--box-shadow); }
        
        /* Header Layout */
        .header { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; border-bottom: 2px solid var(--border-color); padding-bottom: 15px; }
        .header-row { display: flex; flex-wrap: wrap; gap: 15px; align-items: stretch; }

        .control-group { display: flex; gap: 10px; align-items: center; background: var(--bg-control); padding: 8px 15px; border-radius: 8px; border: 1px solid var(--border-color); }
        .control-group h3 { margin: 0 10px 0 0; font-size: 15px; color: var(--text-main); white-space: nowrap; }
        
        button { padding: 6px 12px; font-size: 14px; cursor: pointer; border: none; border-radius: 6px; transition: 0.2s; font-weight: bold; white-space: nowrap;}
        button:disabled { background: #e0e0e0; color: #999; cursor: not-allowed; }
        .dark-mode button:disabled { background: #444; color: #777; }
        
        .btn-connect { background: #007bff; color: white; }
        .btn-disconnect { background: #dc3545; color: white; }
        .btn-clear { background: #6c757d; color: white; }
        .btn-config { background: #17a2b8; color: white; } 
        .btn-add { background: #28a745; color: white; font-size: 16px; padding: 4px 12px; }
        .btn-remove { background: #dc3545; color: white; padding: 4px 8px; font-size: 12px; }
        .btn-set-all { background: #6610f2; color: white; }
        .btn-disable-all { background: #dc3545; color: white; } 
        .btn-update { background: #17a2b8; color: white; padding: 4px 8px; font-size: 13px;}

        /* Input & Select Styling */
        input[type="number"] { width: 60px; padding: 5px; border: 1px solid #ccc; border-radius: 4px; background: var(--bg-container); color: var(--text-main); }
        select { padding: 5px; border: 1px solid #ccc; border-radius: 4px; background: var(--bg-container); color: var(--text-main); cursor: pointer; }
        
        input[type="checkbox"] { transform: scale(1.2); margin-right: 5px; cursor: pointer; }
        label { cursor: pointer; user-select: none; font-weight: 500; display: flex; align-items: center; white-space: nowrap; }
        
        /* Config Section Styles */
        .config-section { background-color: var(--bg-control); border: 1px solid #ddd; flex-direction: column; align-items: flex-start; padding: 0; overflow: hidden; margin-bottom: 10px; border-radius: 8px;}
        .dark-mode .config-section { border-color: #444; }

        .config-header { 
            width: 100%; padding: 8px 15px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; 
            transition: background 0.2s; box-sizing: border-box;
        }
        .config-header:hover { background: rgba(0,0,0, 0.05); }
        .dark-mode .config-header:hover { background: rgba(255,255,255, 0.05); }
        
        .config-header h3 { margin: 0; display: flex; align-items: center; gap: 8px; font-size: 15px;}

        /* Specific colors */
        .section-tmp117 { border-color: #17a2b8; }
        .section-tmp117 .config-header { background: rgba(23, 162, 184, 0.1); }
        .section-tmp117 h3 { color: #17a2b8; }
        .section-tmp117 .config-toolbar { border-bottom: 1px solid #17a2b8; }
		
		.section-ltc2983 { border-color: #fd7e14; }
        .section-ltc2983 .config-header { background: rgba(253, 126, 20, 0.1); }
        .section-ltc2983 h3 { color: #fd7e14; }
        .section-ltc2983 .config-toolbar { border-bottom: 1px solid #fd7e14; }

        .section-anomaly { border-color: #dc3545; }
        .section-anomaly .config-header { background: rgba(220, 53, 69, 0.1); }
        .section-anomaly h3 { color: #dc3545; }
        .section-anomaly .config-toolbar { border-bottom: 1px solid #dc3545; }

        .config-toolbar {
            width: 100%; padding: 10px 15px; 
            background: var(--bg-container); 
            display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;
            box-sizing: border-box; 
        }
        
		/* [æ–°å¢] æª”æ¡ˆå­˜å–å·¥å…·åˆ—å°ˆç”¨æ¨£å¼ */
		.file-action-group {
			display: flex; 
			align-items: center; 
			gap: 8px; 
			padding-left: 15px; 
			margin-left: 15px; 
			border-left: 2px solid var(--border-color); /* ä½¿ç”¨è®Šæ•¸è®“æ·±è‰²æ¨¡å¼ä¹Ÿå¥½çœ‹ */
			height: 30px; /* å›ºå®šé«˜åº¦è®“åˆ†éš”ç·šæ•´é½Š */
		}
		
		/* æª”æ¡ˆæ“ä½œæŒ‰éˆ•å…±ç”¨æ¨£å¼ */
		.btn-file {
			display: inline-flex;
			align-items: center;
			gap: 5px;
			padding: 5px 12px;
			font-size: 13px;
			font-weight: 600;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			transition: background 0.2s, transform 0.1s;
			color: white;
			box-shadow: 0 2px 4px rgba(0,0,0,0.1);
		}
		
		.btn-file:hover {
			transform: translateY(-1px);
			box-shadow: 0 4px 6px rgba(0,0,0,0.15);
		}
		
		.btn-file:active {
			transform: translateY(0);
		}
		
		.btn-file svg {
			width: 14px;
			height: 14px;
			fill: currentColor;
		}
		
		/* å€‹åˆ¥é¡è‰²å®šç¾© */
		.btn-export { background-color: #17a2b8; }
		.btn-export:hover { background-color: #138496; }
		
		.btn-import { background-color: #28a745; }
		.btn-import:hover { background-color: #218838; }
		
        .config-content { 
            display: none; padding: 10px 15px; width: 100%; 
            background: var(--bg-control); 
            animation: slideDown 0.3s ease-out; box-sizing: border-box;
        }
        .config-content.show { display: block; }

        .toggle-arrow { transition: transform 0.3s; font-size: 12px; }
        
        #configRowsContainer, #anomalyRowsContainer { display: flex; flex-direction: column; gap: 8px; width: 100%; }
        .config-row { display: flex; align-items: center; gap: 8px; background: var(--bg-container); padding: 5px; border-radius: 4px; border: 1px solid var(--border-color); animation: fadeIn 0.3s; }
        
        /* Chart Layout */
        .charts-area { display: flex; gap: 20px; flex-wrap: nowrap; align-items: flex-start; overflow-x: auto; margin-bottom: 20px; }
        
        .chart-box { 
            background: var(--bg-container); 
            border: 1px solid var(--border-color); 
            border-radius: 8px; 
            padding: 15px; 
            transition: all 0.3s ease; 
            min-width: 0; 
            display: flex;
            flex-direction: column;
        }

        .main-chart { flex: 3; }
        .side-chart { flex: 1; }
        .full-width { width: 100%; margin-top: 20px; }

        .chart-box.collapsed { flex: 0 0 auto; width: auto; }
        .chart-box.collapsed .box-content { display: none; }
        .chart-box.collapsed .box-header { margin-bottom: 0; white-space: nowrap; }

        .box-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; background: var(--header-bg); padding: 10px; border-radius: 5px; margin-bottom: 10px; white-space: nowrap; }
        .box-header:hover { background: var(--header-hover); }
        .box-title { font-weight: bold; margin: 0; }
        .toggle-icon { font-size: 12px; transition: transform 0.2s; }
        .collapsed .toggle-icon { transform: rotate(-90deg); }

        .chart-wrapper { position: relative; height: 450px; width: 100%; } 

        .scroll-container { margin-top: 10px; display: flex; align-items: center; gap: 10px; color: var(--text-main); }
        input[type=range] { flex-grow: 1; cursor: pointer; }
        .scroll-info { font-size: 12px; color: var(--text-sub); min-width: 120px; text-align: right; font-family: monospace; }

        .color-inputs-container { display: flex; gap: 15px; flex-wrap: wrap; padding: 5px; }
        .color-item { display: flex; align-items: center; gap: 8px; background: var(--bg-control); padding: 5px 10px; border-radius: 20px; border: 1px solid var(--border-color); }
        .color-item label { font-weight: bold; font-family: monospace; cursor: pointer; margin: 0; }
        .color-item input[type="color"] { border: none; width: 30px; height: 30px; padding: 0; background: none; cursor: pointer; border-radius: 50%; overflow: hidden; }

        .status-badge { padding: 5px 10px; border-radius: 20px; font-size: 12px; font-weight: bold; margin-left: 10px; white-space: nowrap; }
        .status-disconnected { background: #ffeeba; color: #856404; }
        .status-connected { background: #d4edda; color: #155724; }

        #errorBanner {
            display: none;
            width: 100%;
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            background-color: var(--error-bg);
            color: var(--error-text);
            border: 1px solid var(--error-border);
            font-weight: bold;
            display: flex;
            align-items: center;
            animation: fadeIn 0.3s ease-in-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
		
		/* ========================================= */
        /* [æ–°å¢] ä¸‹æ‹‰é¸å–® Disabled é¸é …æ¨£å¼å„ªåŒ– */
        /* ========================================= */
        select option:disabled {
            color: var(--text-sub);        /* ä½¿ç”¨å‰¯æ¨™é¡Œé¡è‰² (åœ¨æš—é»‘æ¨¡å¼ä¸‹æ˜¯æ·±ç°ï¼Œäº®è‰²æ¨¡å¼æ˜¯æ·ºç°) */
            background-color: var(--bg-control); /* èƒŒæ™¯è·Ÿéš¨æ§åˆ¶é …èƒŒæ™¯ï¼Œä¸æœƒè®Šç™½ */
            font-style: italic;            /* ç”¨æ–œé«”å€åˆ† */
            opacity: 0.5;                  /* å¢åŠ é€æ˜åº¦ */
        }

        /* é‡å° Chrome/Edge çš„å¼·åˆ¶æš—è‰²è¦†è“‹ (ç€è¦½å™¨æœ‰æ™‚æœƒé ‘å›ºåœ°ç”¨ç™½è‰²èƒŒæ™¯) */
        body.dark-mode select option:disabled {
            color: #777;                   /* æš—é»‘æ¨¡å¼ä¸‹çš„æ–‡å­—é¡è‰² */
            background-color: #2d2d2d;     /* æš—é»‘æ¨¡å¼ä¸‹çš„èƒŒæ™¯é¡è‰² */
        }
		/* [æ–°å¢] é€²éšåƒæ•¸å€å¡Šæ¨£å¼ */
		.params-container {
			display: flex; 
			gap: 15px; /* æ¯å€‹é¸é …ä¹‹é–“çš„é–“è· */
			align-items: center; 
			background: var(--bg-control); /* ä½¿ç”¨è®Šæ•¸èƒŒæ™¯è‰² */
			padding: 4px 8px; 
			border-radius: 4px; 
			border: 1px solid var(--border-color);
		}
		
		/* åƒæ•¸æ¨™ç±¤æ¨£å¼ (å°é½Šç”¨) */
		.param-label {
			display: flex;
			align-items: center;
			gap: 4px;
			font-size: 13px;
			font-weight: 500;
			cursor: pointer;
			white-space: nowrap; /* é˜²æ­¢æ–‡å­—æ›è¡Œ */
		}
		
		/* Hex æ•¸å€¼é¡¯ç¤ºå€ */
		.hex-preview {
			font-family: 'Consolas', 'Courier New', monospace;
			background-color: #222; /* æ”¹æ·±ä¸€é»çš„åº•è‰² */
			border: 1px solid #444;
			color: #00ff00;
			padding: 4px 8px;       /* å¢åŠ ä¸€é»å…§è· */
			border-radius: 4px;
			font-size: 11px;        /* å­—é«”ç¨å¾®ç¸®å°ä¸€é»ä»¥å®¹ç´æ›´å¤šè³‡è¨Š */
			line-height: 1.4;       /* å¢åŠ è¡Œé«˜ */
			min-width: 140px;       /* åŠ å¯¬ */
			text-align: left;       /* æ”¹ç‚ºé å·¦å°é½Š */
			display: inline-block;
			vertical-align: middle;
		}
		
		/* è®“è£¡é¢çš„æ¨™ç±¤æœ‰é¡è‰²å€åˆ† */
		.hex-label {
			color: #888;
			font-weight: normal;
			margin-right: 4px;
		}
		
		
    </style>
</head>
<body class="">

<div class="container">
    <div class="header">
        
        <div class="header-row">
            
            <div class="control-group">
                <h3>ğŸ”Œ é€£ç·š</h3>
                <button id="connectBtn" class="btn-connect">é€£æ¥</button>
                <button id="disconnectBtn" class="btn-disconnect" disabled>æ–·é–‹</button>
                <span id="status" class="status-badge status-disconnected">æœªé€£ç·š</span>
            </div>

            <div class="control-group">
                <h3>ğŸ› ï¸ æ“ä½œ</h3>
                <button class="btn-clear" onclick="clearCharts()">ğŸ§¹ æ¸…é™¤</button>
                <label style="margin-left: 10px; cursor: pointer;">
                    <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()" checked> æš—é»‘
                </label>
                
                <div style="margin-left: 15px; padding-left: 15px; border-left: 1px solid #ccc; display:flex; gap:5px; align-items:center;">
                    <label title="STM32 æ•¸æ“šå›å‚³é–“éš”">Freq:</label>
                    <input type="number" id="cfg_interval" value="1000" min="10" step="100" style="width:60px;">
                    <span style="font-size:12px; color:var(--text-sub);">ms</span>
                    <button class="btn-update" onclick="updateTxInterval()">Set</button>
                </div>
            </div>
        </div>

        <div class="header-row">
            <div class="control-group" style="width: 100%; border-left: 4px solid #17a2b8;">
                <h3 style="color: #17a2b8;">ğŸ’¾ è®€å¯« (Data I/O)</h3>
                
                <div class="file-action-group" style="margin-left: 0; padding-left: 0; border-left: none; margin-right: 20px;">
                    <span style="font-size: 12px; font-weight: bold; color: var(--text-sub); margin-right: 2px;">CONFIG:</span>
                    <button onclick="exportSettings()" class="btn-file btn-export" title="ä¸‹è¼‰å®Œæ•´è¨­å®šæª” (.json)">
                        <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                        åŒ¯å‡º
                    </button>
                    <button onclick="triggerImport()" class="btn-file btn-import" title="è®€å–è¨­å®šæª” (.json)">
                        <svg viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>
                        åŒ¯å…¥
                    </button>
                    <input type="file" id="importFile" style="display: none" onchange="importSettings(this)">
                </div>

                <div style="height: 24px; width: 1px; background: #ddd; margin-right: 20px;"></div>

                <div style="display: flex; align-items: center;">
                    <label title="æ¯æ”¶é›† N ç­†è³‡æ–™è‡ªå‹•å­˜æª”" style="font-weight:bold; color:#28a745; margin-right: 5px;">Auto Save:</label>
                    <input type="number" id="cfg_auto_save_count" value="1000" min="10" step="10" style="width:55px; margin-right: 10px;" onchange="saveAutoSaveSettings()">
                    
                    <label title="å­˜æˆ Excel è¡¨æ ¼" style="margin-right: 10px; cursor: pointer; display: flex; align-items: center;">
                        <input type="checkbox" id="cfg_auto_csv_enable" onchange="saveAutoSaveSettings()" style="margin-right: 3px;">
                        <span style="font-weight:bold;">CSV</span>
                    </label>

                    <label title="å­˜æˆæ­·å²è¶¨å‹¢åœ– (PNG)" style="margin-right: 15px; cursor: pointer; display: flex; align-items: center;">
                        <input type="checkbox" id="cfg_auto_img_enable" onchange="saveAutoSaveSettings()" style="margin-right: 3px;">
                        <span style="font-weight:bold;">IMG</span>
                    </label>

                    <button id="btn_select_folder" onclick="selectLogFolder()" class="btn-file" style="background-color: #f8f9fa; color: #333; border: 1px solid #ced4da; margin-right: 10px;">
                        ğŸ“‚ ç›®éŒ„
                    </button>

                    <span id="save_progress" style="font-size: 12px; color: #666; font-family: monospace; font-weight: bold; min-width: 60px;">(0/1000)</span>
                </div>
            </div>
        </div>

        <div class="header-row">
            <div class="control-group" style="width: 100%;">
                <h3>âš™ï¸ é¡¯ç¤º</h3>
                
                <label style="margin-right: 15px;">
                    <input type="checkbox" id="autoScale" checked onchange="toggleManualInput()"> è‡ªå‹•ç¸®æ”¾
                </label>
                
                <label style="margin-right: 15px; color: #007bff; font-weight:bold;">
                    <input type="checkbox" id="showAddrToggle" onchange="forceUpdateChart()"> é¡¯ç¤ºä½å€
                </label>

                <div style="padding-left: 15px; border-left: 1px solid #ccc; display:flex; gap:5px; align-items:center; margin-right: 15px;">
                    <label title="ç¸½å„²å­˜ç­†æ•¸">Store:</label>
                    <input type="number" id="cfg_max_points" value="2000" min="100" max="10000" style="width:55px;">
                    
                    <label title="è¦–çª—é¡¯ç¤ºç­†æ•¸">View:</label>
                    <input type="number" id="cfg_window_size" value="50" min="10" max="1000" style="width:45px;">
                    
                    <button class="btn-update" onclick="updateBufferSettings()">Set</button>
                </div>

                <div id="manualInput" style="display:none; padding-left: 10px; border-left: 1px solid #ccc;">
                    <input type="number" id="yMin" value="20" placeholder="Min" style="width:45px;"> ~ 
                    <input type="number" id="yMax" value="40" placeholder="Max" style="width:45px;">
                    <button onclick="forceUpdateChart()" style="padding: 4px 6px;">Update</button>
                </div>
            </div>
        </div>

    </div>

        <div class="control-group config-section section-tmp117">
            <div class="config-header" onclick="toggleConfigSection('configContent', 'configToggleIcon')">
                <h3>
                    <span>ğŸ”§ TMP117 å¤šé€šé“é…ç½®</span>
                    <span id="configToggleIcon" class="toggle-arrow">â–¼</span>
                </h3>
                <span style="font-size: 12px; color: #666;">(é»æ“Šå±•é–‹/æ”¶åˆ)</span>
            </div>


		
		<div class="config-toolbar">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <button class="btn-add" onclick="addConfigRow()" title="å¢åŠ ä¸€åˆ—é…ç½®">+</button>
                    <button class="btn-set-all" id="btn_set_all" onclick="setAllRows()" disabled title="ä¾åºç™¼é€æ‰€æœ‰é…ç½®">ğŸš€ Set All</button>
                    <button class="btn-disable-all" id="btn_disable_all" onclick="disableAllChannels()" disabled title="é—œé–‰æ‰€æœ‰å·²é–‹å•Ÿçš„é€šé“">ğŸ›‘ Disable All</button>
                </div>

                <div style="display: flex; align-items: center; gap: 5px; padding: 0 10px; border-left: 2px solid #ddd; margin-left: 5px;">
                    <span style="font-size: 13px; font-weight: bold; color: #17a2b8;">çµ±ä¸€ Addr:</span>
                    <select id="batchAddrSelect" style="padding: 2px; font-size: 13px;">
                        <option value="72">0x48</option>
                        <option value="73">0x49</option>
                        <option value="74">0x4A</option>
                        <option value="75">0x4B</option>
                        <option value="0" style="color:red;">OFF</option>
                    </select>
                    <button class="btn-update" onclick="applyBatchAddr()" title="å°‡æ­¤ä½å€å¥—ç”¨åˆ°ä¸‹æ–¹æ‰€æœ‰åˆ—" style="background-color: #6c757d; color: white; border: none; padding: 2px 8px; cursor: pointer;">Apply</button>
                </div>
                <div style="display: flex; gap: 15px; align-items: center; margin-left: 10px;">
                    <label style="font-size:13px; color:#555;">
                        <input type="checkbox" id="skipDisableConfirm" checked>è·³éç¢ºèª
                    </label>
					<label style="font-size:13px; color:#dc3545; font-weight:bold;">
						<input type="checkbox" id="clearDataOnDisable" checked> é—œé–‰æ™‚æ¸…é™¤æ•¸æ“š
					</label>
                </div>
            </div>
            <div id="configContent" class="config-content">
                <div id="configRowsContainer"></div>
            </div>
        </div>
		
		<div class="control-group config-section section-ltc2983">
            <div class="config-header" onclick="toggleConfigSection('ltcConfigContent', 'ltcConfigToggleIcon')">
                <h3>
                    <span>ğŸ”¥ LTC2983 å¤šé€šé“é…ç½®</span>
                    <span id="ltcConfigToggleIcon" class="toggle-arrow">â–¼</span>
                </h3>
                <span style="font-size: 12px; color: #666;">(é»æ“Šå±•é–‹/æ”¶åˆ)</span>
            </div>

            <div class="config-toolbar">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <button class="btn-add" onclick="addLTCConfigRow()" title="å¢åŠ ä¸€åˆ—é…ç½®" style="background:#fd7e14;">+</button>
                    <button id="btn_set_all_ltc" class="btn-set-all" onclick="setAllLTCRows()" title="ä¾åºç™¼é€æ‰€æœ‰ LTC é…ç½®" style="background:#d63384;" disabled>ğŸš€ Set All LTC</button>
                    <button id="btn_disable_all_ltc" class="btn-disable-all" onclick="disableAllLTCChannels()" title="é—œé–‰æ‰€æœ‰ LTC é€šé“" style="background:#dc3545;" disabled>ğŸ›‘ Disable All</button>
				</div>
				
                <div style="display: flex; align-items: center; gap: 5px; padding: 0 10px; border-left: 2px solid #ddd; margin-left: 5px;">
                    <span style="font-size: 13px; font-weight: bold; color: #fd7e14;">çµ±ä¸€ Type:</span>
                    <select id="batchLtcTypeSelect" style="padding: 2px; font-size: 13px;">
                        <option value="0">NONE (Off)</option>
                        <option value="1">Type J</option>
                        <option value="2">Type K</option>
                        <option value="3">Type T</option>
                        <option value="4">Type E</option>
                    </select>
                    <button class="btn-update" onclick="applyBatchLTCType()" style="background-color: #6c757d; color: white; border: none; padding: 2px 8px; cursor: pointer;">Apply</button>
                </div>

                <div style="display: flex; gap: 15px; align-items: center; margin-left: 10px;">
                    <label style="font-size:13px; color:#555;">
                        <input type="checkbox" id="skipDisableConfirmLTC" checked>è·³éç¢ºèª
                    </label>
                    <label style="font-size:13px; color:#dc3545; font-weight:bold;">
                        <input type="checkbox" id="clearDataOnDisableLTC" checked> é—œé–‰æ™‚æ¸…é™¤æ•¸æ“š
                    </label>
                </div>
            </div>

            <div id="ltcConfigContent" class="config-content">
                <div id="ltcConfigRowsContainer"></div>
            </div>
        </div>
		
        <div class="control-group config-section section-anomaly">
            <div class="config-header" onclick="toggleConfigSection('anomalyContent', 'anomalyToggleIcon')">
                <h3>
                    <span>ğŸš¨ ç•°å¸¸åµæ¸¬è¨­å®š (Anomaly Rules)</span>
                    <span id="anomalyToggleIcon" class="toggle-arrow">â–¼</span>
                </h3>
                <span style="font-size: 12px; color: #666;">(é»æ“Šå±•é–‹/æ”¶åˆ)</span>
            </div>

            <div class="config-toolbar">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <button class="btn-add" onclick="addAnomalyRow()" title="å¢åŠ ä¸€æ¢è¦å‰‡">+</button>
                </div>
                
                <label style="font-size:13px; color:#dc3545; font-weight:bold;" title="è‹¥å‹¾é¸ï¼Œç¬¦åˆç•°å¸¸è¦å‰‡çš„é€šé“å°‡å¾åœ–è¡¨(æŠ˜ç·šåœ–èˆ‡é•·æ¢åœ–)ä¸­éš±è—">
                    <input type="checkbox" id="filterAnomalies" checked onchange="saveAnomalyRules(); forceUpdateChart();"> å¾åœ–è¡¨éš±è—ç•°å¸¸é€šé“ (Auto-Hide Anomalies)
                </label>
            </div>

            <div id="anomalyContent" class="config-content">
				<div style="padding: 8px; margin-bottom: 10px; background: #fff3cd; border: 1px solid #ffeeba; border-radius: 4px; display: flex; align-items: center; gap: 10px;">
					<span style="font-size: 20px;">âš ï¸</span>
					<label style="font-weight: bold; color: #856404;">
						é€£çºŒç›¸åŒæ•¸å€¼ (Stuck) åˆ¤å®šæ–·ç·šæ¬¡æ•¸:
					</label>
					<input type="number" id="stuckThresholdInput" value="5" min="1" style="width: 60px; text-align: center; font-weight: bold;">
					<span style="font-size: 12px; color: #856404;">(é è¨­ 5 æ¬¡, å³ç´„ 0.5~1 ç§’)</span>
					</div>
                <div id="anomalyRowsContainer"></div>
            </div>
        </div>

    </div>

    <div id="errorBanner" style="display: none;">
        <span style="font-size: 20px; margin-right: 10px;">âš ï¸</span>
        <span id="errorMessage">åµæ¸¬åˆ°ç•°å¸¸:</span>
    </div>
    
    <div class="charts-area">
        <div class="chart-box main-chart" id="historyBox">
            <div class="box-header" onclick="toggleBox('historyBox')">
                <p class="box-title">ğŸ“‰ æ­·å²æº«åº¦è¶¨å‹¢</p>
                <span class="toggle-icon">â–¼</span>
            </div>
            <div class="box-content">
                <div class="chart-wrapper">
                    <canvas id="historyChart"></canvas>
                </div>
                <div class="scroll-container">
                    <span style="font-size:12px;">å›æ”¾:</span>
                    <input type="range" id="historyScroll" min="0" max="0" value="0" step="1" oninput="onScrollChange()" disabled>
                    <span id="scrollInfo" class="scroll-info">Buffering...</span>
                </div>
            </div>
        </div>
        
        <div class="chart-box side-chart" id="barBox">
            <div class="box-header" onclick="toggleBox('barBox')">
                <p class="box-title">ğŸ“Š å³æ™‚å€¼</p>
                <span class="toggle-icon">â–¼</span>
            </div>
            <div class="box-content">
                <div class="chart-wrapper">
                    <canvas id="currentBarChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- <div class="chart-box full-width" id="colorSettingsBox"> -->
        <!-- <div class="box-header" onclick="toggleBox('colorSettingsBox')"> -->
            <!-- <p class="box-title">ğŸ¨ é€šé“é¡è‰²è¨­å®š (Channel Colors)</p> -->
            <!-- <span class="toggle-icon">â–¼</span> -->
        <!-- </div> -->
        <!-- <div class="box-content"> -->
            <!-- <div id="colorInputsContainer" class="color-inputs-container"> -->
                <!-- <span style="color: var(--text-sub); font-style: italic;">ç­‰å¾…æ•¸æ“šä¸­... (é¡è‰²è¨­å®šæœƒè‡ªå‹•å‡ºç¾)</span> -->
            <!-- </div> -->
        <!-- </div> -->
    <!-- </div> -->
	
	<div class="chart-box full-width" id="colorSettingsBox">
        <div class="box-header" onclick="toggleBox('colorSettingsBox')">
            <p class="box-title">ğŸ¨ é€šé“é¡è‰²è¨­å®š (Channel Colors)</p>
            <span class="toggle-icon">â–¼</span>
        </div>
        <div class="box-content" style="padding: 10px;">
            
            <div class="config-section" style="margin-bottom: 10px; border: 1px solid var(--border-color);">
                <div class="config-header" onclick="toggleConfigSection('colorContentTMP', 'colorIconTMP')">
                    <h3 style="font-size:14px; color:#17a2b8;">
                        ğŸŒ¡ï¸ TMP117 Colors (CH0~CH15)
                    </h3>
                    <span id="colorIconTMP" class="toggle-arrow" style="transform: rotate(-90deg);">â–¼</span>
                </div>
                <div id="colorContentTMP" class="config-content" style="display:none;">
                    <div id="containerTMP" class="color-inputs-container"></div>
                </div>
            </div>

            <div class="config-section" style="border: 1px solid var(--border-color);">
                <div class="config-header" onclick="toggleConfigSection('colorContentLTC', 'colorIconLTC')">
                    <h3 style="font-size:14px; color:#fd7e14;">
                        ğŸ”¥ LTC2983 Colors (LTC_1~LTC_20)
                    </h3>
                    <span id="colorIconLTC" class="toggle-arrow" style="transform: rotate(-90deg);">â–¼</span>
                </div>
                <div id="colorContentLTC" class="config-content" style="display:none;">
                    <div id="containerLTC" class="color-inputs-container"></div>
                </div>
            </div>

        </div>
    </div>
	
	<div class="chart-box full-width" id="logBox" style="margin-top: 20px;">
        <div class="box-header" onclick="toggleBox('logBox')">
            <p class="box-title">ğŸ“ é€šè¨Šæ—¥èªŒ (Communication Log)</p>
            <span class="toggle-icon">â–¼</span>
        </div>
        <div class="box-content">
            <div class="config-toolbar" style="border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px;">
                <label style="font-weight:bold; cursor:pointer; display:flex; align-items:center; gap:5px;">
                    <input type="checkbox" id="enableLogging"> 
                    <span style="color: var(--text-main);">å•Ÿç”¨ç´€éŒ„ (Start Logging)</span>
                </label>
				
				<div style="display:flex; align-items:center; gap:5px; border-left:1px solid #666; padding-left:15px;">
                    <span style="font-size:13px; color:var(--text-sub);">Max Lines:</span>
                    <input type="number" id="cfg_log_lines" value="100" min="10" step="10" style="width:60px; padding:2px;">
                    <button class="btn-update" onclick="updateLogSettings()">Set</button>
                </div>
                
                <button class="btn-remove" onclick="clearLog()" style="margin-left: 15px; padding: 4px 12px; font-size: 13px;">
                    ğŸ—‘ï¸ æ¸…é™¤æ—¥èªŒ (Clear)
                </button>
            </div>
            
            <div id="commLogArea" style="
                height: 250px; 
                overflow-y: auto; 
                background: #1e1e1e; 
                color: #00ff00; 
                padding: 10px; 
                font-family: 'Consolas', 'Courier New', monospace; 
                border: 1px solid var(--border-color); 
                border-radius: 4px; 
                font-size: 12px; 
                line-height: 1.4; 
                white-space: pre-wrap;
                box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            "></div>
        </div>
    </div>

</div>

<script>
	let channelStuckCounts = {}; // è¨˜éŒ„æ¯å€‹é€šé“æ•¸å€¼é‡è¤‡çš„æ¬¡æ•¸
    <!-- const STUCK_THRESHOLD = 20;  // é–¾å€¼ï¼šé€£çºŒ 20 ç­†è³‡æ–™å®Œå…¨ç›¸åŒè¦–ç‚ºç•°å¸¸ (ç´„ 2ç§’) -->
    let stuckThreshold = 5;
	let port, reader, writer, inputDone, outputDone;
    let isConnected = false;
    const defaultPalette = ['#36a2eb', '#ff6384', '#4bc0c0', '#ff9f40', '#9966ff', '#ffcd56', '#c9cbcf'];
    
    let channelColors = {};
    let channelAddressMap = {}; 
    let hiddenChannels = new Set();
    let lastReceivedData = [];
    
	let MAX_LOG_LINES = 200;
    let MAX_STORED_POINTS = 2000;
    let VIEW_WINDOW_SIZE = 50;

    let isBulkDisabling = false;

    let anomalyRules = [
        { op: '=', val: 0 } 
    ];
	// [ä¿®æ”¹] LTC2983 æ„Ÿæ¸¬å™¨é¡å‹å®šç¾© (å®Œå…¨å°æ‡‰ STM32 C code enum)
    const LTC_TYPES = [
        { value: 0,  name: "NONE (Unassigned)" },
        
        // --- Thermocouples (ç†±é›»å¶) ---
        { value: 1,  name: "Thermocouple - Type J" },
        { value: 2,  name: "Thermocouple - Type K" },
        { value: 3,  name: "Thermocouple - Type E" },
        { value: 4,  name: "Thermocouple - Type N" },
        { value: 5,  name: "Thermocouple - Type R" },
        { value: 6,  name: "Thermocouple - Type S" },
        { value: 7,  name: "Thermocouple - Type T" },
        { value: 8,  name: "Thermocouple - Type B" },
        { value: 9,  name: "Thermocouple - Custom" },

        // --- RTDs (é›»é˜»æ¸¬æº«é«”) ---
        { value: 10, name: "RTD - PT-10" },
        { value: 11, name: "RTD - PT-50" },
        { value: 12, name: "RTD - PT-100" },
        { value: 13, name: "RTD - PT-200" },
        { value: 14, name: "RTD - PT-500" },
        { value: 15, name: "RTD - PT-1000" },
        { value: 16, name: "RTD - 1000 (0.00375)" },
        { value: 17, name: "RTD - NI-120" },
        { value: 18, name: "RTD - Custom" },

        // --- Thermistors (ç†±æ•é›»é˜») ---
        { value: 19, name: "Thermistor - 44004 (2.252k)" },
        { value: 20, name: "Thermistor - 44005 (3k)" },
        { value: 21, name: "Thermistor - 44007 (5k)" },
        { value: 22, name: "Thermistor - 44006 (10k)" },
        { value: 23, name: "Thermistor - 44008 (30k)" },
        { value: 24, name: "Thermistor - YSI 400 (2.252k)" },
        { value: 25, name: "Thermistor - Spectrum 1003 (1k)" },
        { value: 26, name: "Thermistor - Custom (Steinhart-Hart)" },
        { value: 27, name: "Thermistor - Custom (Table)" },

        // --- Others (å…¶ä»–) ---
        { value: 28, name: "Diode" },
        { value: 29, name: "Sense Resistor (Rsense)" },
        { value: 30, name: "Direct ADC" }
    ];

    // è¼”åŠ©å‡½å¼ï¼šç”¢ç”Ÿé¸å–® HTML
    function generateLTCTypeOptions(selectedValue) {
        return LTC_TYPES.map(type => {
            // å®šç¾©å…è¨±é–‹æ”¾çš„ ID
            const allowedIDs = [0, 2, 28];
            
            // åˆ¤æ–·æ˜¯å¦å•Ÿç”¨
            const isEnabled = allowedIDs.includes(type.value);
            
            // å¦‚æœä¸å•Ÿç”¨ï¼ŒåŠ å…¥ disabled å±¬æ€§
            const disabledAttr = isEnabled ? '' : 'disabled';       

            return `<option value="${type.value}" ${type.value == selectedValue ? 'selected' : ''} ${disabledAttr}>
                        ${type.name}
                    </option>`;
        }).join('');
    }
	
    // åˆå§‹åŒ–
    window.addEventListener('DOMContentLoaded', () => {
        loadConfigRows();
		<!-- loadLTCConfigRows();     -->
        loadBufferSettings(); 
        loadAnomalyRules(); 
        loadLogSettings(); 
		
		// [æ–°å¢] åˆå§‹åŒ– LTC æ‰¹é‡è¨­å®šé¸å–®
        const batchSelect = document.getElementById('batchLtcTypeSelect');
        if (batchSelect) {
            batchSelect.innerHTML = generateLTCTypeOptions(0); // é è¨­é¸ä¸­ 0 (NONE)
        }

        // è¼‰å…¥ LTC è¨­å®šåˆ— (é€™è¡Œè¦æ”¾åœ¨ä¸Šé¢åˆå§‹åŒ–ä¹‹å¾Œï¼Œå› ç‚º loadLTCConfigRows æœƒç”¨åˆ° generateLTCTypeOptions)
        loadLTCConfigRows();
		
		// ã€æ–°å¢ã€‘è¼‰å…¥ä¸Šæ¬¡çš„é–“éš”è¨­å®š
        const savedInterval = localStorage.getItem('stm32_tx_interval');
        if (savedInterval) {
            const el = document.getElementById('cfg_interval');
            if(el) el.value = savedInterval;
        }
		
		// --- ã€æ–°å¢ã€‘è¼‰å…¥æ­»é–æ¬¡æ•¸è¨­å®š ---
        const savedStuck = localStorage.getItem('stm32_stuck_threshold');
        if (savedStuck) {
            stuckThreshold = parseInt(savedStuck);
            // ç¢ºä¿ä»‹é¢é¡¯ç¤ºæ­£ç¢ºçš„æ•¸å€¼
            const input = document.getElementById('stuckThresholdInput');
            if(input) input.value = stuckThreshold;
        }
		
		// --- ã€æ–°å¢ã€‘ç›£è½è¼¸å…¥æ¡†è®ŠåŒ– ---
        const stuckInput = document.getElementById('stuckThresholdInput');
        if (stuckInput) {
            stuckInput.addEventListener('change', (e) => {
                let val = parseInt(e.target.value);
                if (isNaN(val) || val < 1) val = 1; // æœ€å°ç‚º 1
                
                stuckThreshold = val; // æ›´æ–°å…¨åŸŸè®Šæ•¸
                localStorage.setItem('stm32_stuck_threshold', val); // å„²å­˜è¨­å®š
                
                // ç«‹å³æ›´æ–°åœ–è¡¨ï¼Œè®“æ•ˆæœé¦¬ä¸Šé¡¯ç¤º
                updateChartWindow(); 
            });
        }
		
        ['configToggleIcon', 'anomalyToggleIcon', 'ltcConfigToggleIcon'].forEach(id => {
            const icon = document.getElementById(id);
            if (icon) icon.style.transform = "rotate(-90deg)";
        });
    });

    try {
        const savedColors = localStorage.getItem('stm32_channel_colors');
        if (savedColors) {
            channelColors = JSON.parse(savedColors);
        }
    } catch(e) { console.error("Load colors failed", e); }

    let historyChart;
    let currentBarChart;
    const ctxHistory = document.getElementById('historyChart').getContext('2d');
    const ctxBar = document.getElementById('currentBarChart').getContext('2d');
    
    let globalData = { labels: [], channels: {} };
    let globalSampleCount = 0;
    let isAutoScroll = true;

    const checkAnomaly = (val) => {
        if (val === null) return false; 
        for (let rule of anomalyRules) {
            const threshold = parseFloat(rule.val);
            if (isNaN(threshold)) continue;
            let isMatch = false;
            switch(rule.op) {
                case '=': isMatch = (Math.abs(val - threshold) < 0.001); break;
                case '>': isMatch = (val > threshold); break;
                case '<': isMatch = (val < threshold); break;
                case '>=': isMatch = (val >= threshold); break;
                case '<=': isMatch = (val <= threshold); break;
            }
            if (isMatch) return true; 
        }
        return false;
    };


	// [æ–°å¢] æ›´æ–°æ—¥èªŒè¨­å®š
    function updateLogSettings() {
        const el = document.getElementById('cfg_log_lines');
        const val = parseInt(el.value);
        
        if (isNaN(val) || val < 10) {
            alert("è«‹è¼¸å…¥æœ‰æ•ˆçš„è¡Œæ•¸ (æœ€å° 10 è¡Œ)");
            return;
        }
        
        MAX_LOG_LINES = val;
        localStorage.setItem('stm32_log_lines', val);
        
        // ç«‹å³åŸ·è¡Œä¸€æ¬¡ä¿®å‰ªï¼Œå¦‚æœç›®å‰è¡Œæ•¸è¶…éæ–°è¨­å®šï¼Œé¦¬ä¸Šåˆªé™¤èˆŠçš„
        const logArea = document.getElementById('commLogArea');
        while (logArea.children.length > MAX_LOG_LINES) {
            logArea.removeChild(logArea.firstChild);
        }
        
        // alert(`è¨­å®šå·²æ›´æ–°: ä¿ç•™æœ€æ–° ${val} è¡Œæ—¥èªŒ`); // (é¸æ“‡æ€§æç¤º)
    }

    // [æ–°å¢] è¼‰å…¥æ—¥èªŒè¨­å®š (åˆå§‹åŒ–æ™‚å‘¼å«)
    function loadLogSettings() {
        const saved = localStorage.getItem('stm32_log_lines');
        if (saved) {
            const val = parseInt(saved);
            if (!isNaN(val) && val >= 10) {
                MAX_LOG_LINES = val;
                const el = document.getElementById('cfg_log_lines');
                if (el) el.value = val;
            }
        }
    }

    // --- Buffer Settings ---
    function saveBufferSettings() {
        const settings = { max: MAX_STORED_POINTS, view: VIEW_WINDOW_SIZE };
        localStorage.setItem('stm32_buffer_settings', JSON.stringify(settings));
    }

    function loadBufferSettings() {
        const saved = localStorage.getItem('stm32_buffer_settings');
        if (saved) {
            try {
                const s = JSON.parse(saved);
                if (s.max && s.view) {
                    MAX_STORED_POINTS = parseInt(s.max);
                    VIEW_WINDOW_SIZE = parseInt(s.view);
                    document.getElementById('cfg_max_points').value = MAX_STORED_POINTS;
                    document.getElementById('cfg_window_size').value = VIEW_WINDOW_SIZE;
                }
            } catch(e) {}
        }
    }

    function updateBufferSettings() {
        const newMax = parseInt(document.getElementById('cfg_max_points').value);
        const newView = parseInt(document.getElementById('cfg_window_size').value);
        if (isNaN(newMax) || isNaN(newView) || newMax < 100 || newView < 10) {
            alert("è«‹è¼¸å…¥æœ‰æ•ˆçš„æ•¸å€¼ (Store >= 100, View >= 10)");
            return;
        }
        if (newView > newMax) {
            alert("è¦–çª—å¤§å° (View) ä¸èƒ½å¤§æ–¼ç¸½å„²å­˜ç­†æ•¸ (Store)");
            return;
        }
        MAX_STORED_POINTS = newMax;
        VIEW_WINDOW_SIZE = newView;
        if (globalData.labels.length > MAX_STORED_POINTS) {
            const diff = globalData.labels.length - MAX_STORED_POINTS;
            globalData.labels.splice(0, diff);
            Object.values(globalData.channels).forEach(arr => arr.splice(0, diff));
        }
        saveBufferSettings();
        updateScrollbarState();
        updateChartWindow();
        alert(`è¨­å®šå·²æ›´æ–°ä¸¦å„²å­˜: Store=${MAX_STORED_POINTS}, View=${VIEW_WINDOW_SIZE}`);
    }

    // --- Config & Anomaly UI ---
    
    function toggleConfigSection(contentId, iconId) {
        const content = document.getElementById(contentId);
        const icon = document.getElementById(iconId);
        if (content.style.display === 'block') {
            content.style.display = 'none';
            icon.style.transform = "rotate(-90deg)"; 
        } else {
            content.style.display = 'block';
            icon.style.transform = "rotate(0deg)";   
        }
    }

    function addAnomalyRow(op = '=', val = 0) {
        const container = document.getElementById('anomalyRowsContainer');
        const rowId = 'arow-' + Date.now() + Math.random().toString(36).substr(2, 9);
        
        const div = document.createElement('div');
        div.className = 'config-row';
        div.id = rowId;
        div.innerHTML = `
            <label>è‹¥æº«åº¦ 
                <select class="row-op-select">
                    <option value="=" ${op=='='?'selected':''}>= (ç­‰æ–¼)</option>
                    <option value=">" ${op=='>'?'selected':''}>&gt; (å¤§æ–¼)</option>
                    <option value="<" ${op=='<'?'selected':''}>&lt; (å°æ–¼)</option>
                    <option value=">=" ${op=='>='?'selected':''}>&ge; (å¤§æ–¼ç­‰æ–¼)</option>
                    <option value="<=" ${op=='<='?'selected':''}>&le; (å°æ–¼ç­‰æ–¼)</option>
                </select>
            </label>
            <input type="number" class="row-val-input" value="${val}" style="width:70px;">
            <button class="btn-remove" onclick="removeAnomalyRow('${rowId}')">ç§»é™¤</button>
        `;
        container.appendChild(div);

        div.querySelector('.row-op-select').addEventListener('change', saveAnomalyRules);
        div.querySelector('.row-val-input').addEventListener('change', saveAnomalyRules);
        
        const content = document.getElementById('anomalyContent');
        const icon = document.getElementById('anomalyToggleIcon');
        if (content.style.display === 'none') {
            content.style.display = 'block';
            icon.style.transform = "rotate(0deg)";
        }
        
        saveAnomalyRules();
    }

    function removeAnomalyRow(rowId) {
        const row = document.getElementById(rowId);
        if (row) {
            row.remove();
            saveAnomalyRules();
        }
    }

    function saveAnomalyRules() {
        const rows = document.querySelectorAll('#anomalyRowsContainer .config-row');
        const rules = [];
        rows.forEach(row => {
            const op = row.querySelector('.row-op-select').value;
            const val = row.querySelector('.row-val-input').value;
            rules.push({ op, val });
        });
        anomalyRules = rules;
        
        const filter = document.getElementById('filterAnomalies').checked;
        const dataToSave = { rules, filter };
        
        localStorage.setItem('stm32_anomaly_config', JSON.stringify(dataToSave));
        
        updateChartWindow();
        updateBarChart(lastReceivedData);
    }

    function loadAnomalyRules() {
        const saved = localStorage.getItem('stm32_anomaly_config');
        const container = document.getElementById('anomalyRowsContainer');
        container.innerHTML = ''; 

        if (saved) {
            try {
                const data = JSON.parse(saved);
                if (data.rules && Array.isArray(data.rules)) {
                    data.rules.forEach(r => addAnomalyRow(r.op, r.val));
                } else {
                    addAnomalyRow('=', 0); 
                }
                
                if (data.filter !== undefined) {
                    document.getElementById('filterAnomalies').checked = data.filter;
                }
            } catch(e) { addAnomalyRow('=', 0); }
        } else {
            addAnomalyRow('=', 0); 
        }
    }

    // --- Communication ---
	
	// ã€æ–°å¢ã€‘è¨­å®šå‚³é€é–“éš”
    async function updateTxInterval() {
        if (!isConnected) {
            alert("è«‹å…ˆé€£ç·š (Connect)ï¼");
            return;
        }
        
        const input = document.getElementById('cfg_interval');
        const ms = parseInt(input.value);

        // åŸºæœ¬é˜²å‘† (é™åˆ¶æœ€å° 10ms)
        if (isNaN(ms) || ms < 10) {
            alert("ç„¡æ•ˆæ•¸å€¼ï¼æœ€å°é–“éš”ç‚º 10msã€‚");
            return;
        }

        // ç™¼é€æŒ‡ä»¤: CMD:INTERVAL <ms>
        // ä¾‹å¦‚: CMD:INTERVAL 1000
        await sendStringCommand(`CMD:INTERVAL ${ms}`);
        
        // å„²å­˜åˆ° LocalStorage ä»¥ä¾¿ä¸‹æ¬¡é–‹å•Ÿè‡ªå‹•å¸¶å…¥
        localStorage.setItem('stm32_tx_interval', ms);
        
        // ç‚ºäº†è®“ä½¿ç”¨è€…çŸ¥é“æœ‰é€å‡ºï¼Œå¯ä»¥è®“æŒ‰éˆ•é–ƒä¸€ä¸‹æˆ–è·³å€‹æç¤º (é€™è£¡ç”¨ç°¡å–®æç¤º)
        // alert(`å·²ç™¼é€è¨­å®š: ${ms}ms`); // è¦ºå¾—å¤ªåµå¯ä»¥è¨»è§£æ‰é€™è¡Œ
    }

    async function sendStringCommand(cmdString) {
        if (!isConnected || !writer) {
            alert("è«‹å…ˆé€£æ¥è¨­å‚™ï¼");
            return;
        }
        try {
            const data = cmdString + "\r\n";
            await writer.write(data);			
			appendLog("TX", cmdString);			
            console.log("Sent Command:", data.trim());
        } catch (e) {
            alert("ç™¼é€å¤±æ•—: " + e);
        }
    }

    
	
	// ã€ä¿®æ­£ã€‘é—œé–‰æ‰€æœ‰ TMP117 é€šé“
    async function disableAllChannels() {
        if (!isConnected) {
            alert("è«‹å…ˆé€£ç·š (Connect)ï¼");
            return;
        }
        
        if (window.isBulkDisabling) return; 

        // 1. å–å¾—é¸é …ç‹€æ…‹
        const chkBox = document.getElementById('clearDataOnDisable');
        const clearOnDisable = chkBox ? chkBox.checked : false;

        const skipChk = document.getElementById('skipDisableConfirm');
        const skipConfirm = skipChk ? skipChk.checked : false;
        
        if (!skipConfirm) {
            if (!confirm("ç¢ºå®šè¦é—œé–‰æ‰€æœ‰å·²é–‹å•Ÿçš„ TMP117 é€šé“å—ï¼Ÿ")) return;
        }

        window.isBulkDisabling = true;

        try {
            // æ‰¾å‡ºæ‰€æœ‰ TMP117 é€šé“ (åŒ…æ‹¬èˆŠç‰ˆ CHx èˆ‡æ–°ç‰ˆ TMP117_CHx)
            const targetChannels = Object.keys(globalData.channels).filter(key => 
                key.startsWith('CH') || key.startsWith('TMP117_CH')
            );
            
            for (const chKey of targetChannels) {
                // [ä¿®æ­£é‡é»] æ­£ç¢ºè§£æå‡ºç´”æ•¸å­—é€šé“è™Ÿ
                // å…ˆå˜—è©¦ç§»é™¤ TMP117_CHï¼Œå†ç§»é™¤ CHï¼Œç¢ºä¿åªå‰©ä¸‹æ•¸å­—
                let ch = chKey.replace('TMP117_CH', '').replace('CH', '');
                
                // ç™¼é€é—œé–‰æŒ‡ä»¤ (CMD:SET_117 <ch> 0)
                // é€™æ¨£ ch å°±æœƒæ˜¯ç´”æ•¸å­— (ä¾‹å¦‚ "1")ï¼Œè€Œä¸æ˜¯ "TMP117_1"
                await sendStringCommand(`CMD:SET_117 ${ch} 0`);
                
                // ç§»é™¤åœ–è¡¨æ•¸æ“š (è‹¥æœ‰å‹¾é¸)
                if (clearOnDisable) {
                    delete globalData.channels[chKey];
                    hiddenChannels.delete(chKey);
                    
                    // é †ä¾¿æ¸…é™¤ä½å€ç´€éŒ„
                    if (channelAddressMap[chKey]) {
                        delete channelAddressMap[chKey];
                    }
                }
                
                // ç¨å¾®å»¶é²é¿å…æŒ‡ä»¤å¡è»Š
                await new Promise(r => setTimeout(r, 20));
            }
            
            // æ›´æ–°ç•«é¢
            updateChartWindow();
            
        } catch (error) {
            console.error("Disable All Error:", error);
            alert("åŸ·è¡Œ Disable All æ™‚ç™¼ç”ŸéŒ¯èª¤");
        } finally {
            window.isBulkDisabling = false; 
        }
    }

    // --- Config Rows ---
    function saveConfigRows() {
        const rows = document.querySelectorAll('#configRowsContainer .config-row');
        const dataToSave = [];
        rows.forEach(row => {
            const ch = row.querySelector('.row-ch-select').value;
            const addr = row.querySelector('.row-addr-select').value;
            dataToSave.push({ ch, addr });
        });
        localStorage.setItem('stm32_config_rows', JSON.stringify(dataToSave));
    }

    function loadConfigRows() {
        const saved = localStorage.getItem('stm32_config_rows');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                if (Array.isArray(data) && data.length > 0) {
                    data.forEach(item => addConfigRow(item.ch, item.addr));
                    return;
                }
            } catch (e) {}
        }
        addConfigRow(0);
    }

    function addConfigRow(defaultCh = null, defaultAddr = null) {
        const container = document.getElementById('configRowsContainer');
        const rowId = 'row-' + Date.now() + Math.random().toString(36).substr(2, 9);
        
        if (defaultCh === null) {
            const rows = container.querySelectorAll('.row-ch-select');
            if (rows.length > 0) {
                let lastVal = parseInt(rows[rows.length-1].value);
                defaultCh = (lastVal + 1) % 32; 
            } else { defaultCh = 0; }
        }
        // [V41 FIX] ä½å€æ”¹ç‚ºåé€²ä½æ•¸å€¼å­—ä¸²
        if (defaultAddr === null) defaultAddr = "72"; 

        const div = document.createElement('div');
        div.className = 'config-row';
        div.id = rowId;
        div.innerHTML = `
            <label>CH: 
                <select class="row-ch-select">
                    ${generateChannelOptions(defaultCh)}
                </select>
            </label>
            <label>Addr:
                <select class="row-addr-select">
                    <option value="0" style="color:red; font-weight:bold;">OFF</option>
                    <option value="72" ${defaultAddr=="72"?'selected':''}>0x48 (GND)</option>
                    <option value="73" ${defaultAddr=="73"?'selected':''}>0x49 (V+)</option>
                    <option value="74" ${defaultAddr=="74"?'selected':''}>0x4A (SDA)</option>
                    <option value="75" ${defaultAddr=="75"?'selected':''}>0x4B (SCL)</option>
                </select>
            </label>
            <button class="btn-config btn-row-set" onclick="setSingleRow('${rowId}')" ${isConnected ? '' : 'disabled'}>Set</button>
            <button class="btn-remove" onclick="removeConfigRow('${rowId}')">-</button>
        `;
        container.appendChild(div);

        // Auto expand
        const content = document.getElementById('configContent');
        const icon = document.getElementById('configToggleIcon');
        if (content.style.display === 'none') {
            content.style.display = 'block';
            icon.style.transform = "rotate(0deg)";
        }

        div.querySelector('.row-ch-select').addEventListener('change', saveConfigRows);
        div.querySelector('.row-addr-select').addEventListener('change', saveConfigRows);
        saveConfigRows();
    }

    function generateChannelOptions(selected) {
        let opts = '';
        for(let i=0; i<=15; i++) {
            opts += `<option value="${i}" ${i==selected ? 'selected' : ''}>${i}</option>`;
        }
        return opts;
    }

    function removeConfigRow(rowId) {
        const row = document.getElementById(rowId);
        if (row) {
            row.remove();
            saveConfigRows(); 
        }
    }

    async function setSingleRow(rowId) {
        const row = document.getElementById(rowId);
        if (!row) return;
        const ch = row.querySelector('.row-ch-select').value;
        const addr = row.querySelector('.row-addr-select').value;
		<!-- const chkBox = document.getElementById('clearDataOnDisable'); -->
        <!-- const clearOnDisable = chkBox ? chkBox.checked : false; -->
        const clearOnDisable = document.getElementById('clearDataOnDisable').checked;
        await executeConfigCommand(ch, addr, clearOnDisable);
    }

// ã€ä¿®æ­£ç‰ˆã€‘Set All åŠŸèƒ½ (å·²ä¿®å¾© checkbox å ±éŒ¯å•é¡Œ)
    async function setAllRows() {
        const rows = document.querySelectorAll('#configRowsContainer .config-row');
        if (rows.length === 0) return;
        
        // 1. å–å¾— checkbox ç‹€æ…‹ (åŠ å…¥å®‰å…¨æª¢æŸ¥ï¼Œé¿å…æ‰¾ä¸åˆ°ç‰©ä»¶æ™‚ç•¶æ©Ÿ)
        const chkBox = document.getElementById('clearDataOnDisable');
        const clearOnDisable = chkBox ? chkBox.checked : false; 
        
        // 2. ä¾åºç™¼é€æŒ‡ä»¤
        for (const row of rows) {
            const ch = row.querySelector('.row-ch-select').value;
            const addr = row.querySelector('.row-addr-select').value;
            
            // å‘¼å«æŒ‡ä»¤ç™¼é€
            await executeConfigCommand(ch, addr, clearOnDisable);
            
            // ç¨å¾®ç­‰å¾… 10msï¼Œé¿å…æŒ‡ä»¤ç™¼é€å¤ªå¿«å¡è»Š
            await new Promise(r => setTimeout(r, 10));
        }
        
        // 3. é¡¯ç¤ºå®Œæˆæç¤º (å¦‚æœæ²’æœ‰å‹¾é¸è·³éç¢ºèª)
        const skipConfirmBox = document.getElementById('skipDisableConfirm');
        const skipConfirm = skipConfirmBox ? skipConfirmBox.checked : false;
        
        if (!skipConfirm) { 
            alert(`å·²ä¾åºç™¼é€ ${rows.length} çµ„é…ç½®æŒ‡ä»¤ï¼`); 
        }
    }

    // --- [V41 FIX] ä¿®æ­£ä½å€ç™¼é€èˆ‡è§£æé‚è¼¯ ---
    async function executeConfigCommand(ch, addr, clearOnDisable) {
        if (addr === "0") {
             delete channelAddressMap[`CH${ch}`];
             const cmd = `CMD:SET_117 ${ch} 0`;
             await sendStringCommand(cmd);
             if (clearOnDisable) {
                 delete globalData.channels[`CH${ch}`];
                 hiddenChannels.delete(`CH${ch}`);
             }
        } else {
             // ä½å€è½‰æ›ï¼šå¾é¸å–®çš„åé€²ä½(ä¾‹å¦‚ "72")è½‰ç‚ºåå…­é€²ä½å­—ä¸²(ä¾‹å¦‚ "48")ç™¼é€
             const addrInt = parseInt(addr, 10);
             const hexStr = addrInt.toString(16).toUpperCase(); 
             
             // æ›´æ–°æœ¬åœ°é¡¯ç¤ºä½å€
             channelAddressMap[`CH${ch}`] = `0x${hexStr}`;
             
             // ç™¼é€æŒ‡ä»¤ï¼ŒSTM32 ç«¯ API.c ä½¿ç”¨ sscanf(..., "%*s %d %x", ...)
             // å‚³é€ hexStr (å¦‚ "48") çµ¦ STM32 çš„ %x è§£æ
             const cmd = `CMD:SET_117 ${ch} ${hexStr}`;
             await sendStringCommand(cmd);
        }
        updateChartWindow();
    }
    
	function getChannelColor(chName) {
        if (channelColors[chName]) return channelColors[chName];

        if (chName.startsWith('LTC')) {
            // è§£æ LTC_d_c (Device_Channel)
            const parts = chName.split('_');
            // parts[0]="LTC", parts[1]="DevID", parts[2]="ChID"
            const devIdx = parseInt(parts[1]) || 1;
            const chIdx  = parseInt(parts[2]) || 1;
            
            // [ä¿®æ”¹] é¡è‰²æ¼”ç®—æ³•
            // åŸºç¤è‰²ç›¸ï¼šDevice 1 å¾ 0(ç´…)é–‹å§‹, Device 2 å¾ 180(é’)é–‹å§‹... 
            // åŠ ä¸Š (é€šé“ * 15) è®“åŒæ™¶ç‰‡å…§çš„é€šé“é¡è‰²éŒ¯é–‹
            const baseHue = (devIdx - 1) * 120; 
            const hue = (baseHue + (chIdx * 15)) % 360;
            
            return `hsl(${hue}, 90%, 55%)`;
        } 
        else if (chName.startsWith('TMP117')) {
            // TMP117 é‚è¼¯ä¸è®Š
            const chIdx = parseInt(chName.replace('TMP117_CH', '')) || 0;
            return defaultPalette[chIdx % defaultPalette.length];
        }
        else if (chName.startsWith('CH')) {
            // èˆŠç‰ˆç›¸å®¹
            const chIdx = parseInt(chName.replace('CH', '')) || 0;
            return defaultPalette[chIdx % defaultPalette.length];
        }
        
        return '#999';
    }

    function addColorPickerUI(chName, color) {
        const container = document.getElementById('colorInputsContainer');
        if (document.getElementById(`color-picker-${chName}`)) return; 
        if (container.querySelector('span')) container.innerHTML = '';
        const div = document.createElement('div');
        div.className = 'color-item';
        div.innerHTML = `<label for="color-picker-${chName}">${chName}</label><input type="color" id="color-picker-${chName}" value="${color}">`;
        container.appendChild(div);
        div.querySelector('input').addEventListener('input', (e) => {
            updateChannelColor(chName, e.target.value);
        });
    }

    function updateChannelColor(chName, newColor) {
        channelColors[chName] = newColor;
        localStorage.setItem('stm32_channel_colors', JSON.stringify(channelColors));
        historyChart.data.datasets.forEach(ds => {
            if (ds.chName === chName) {
                ds.borderColor = newColor;
                ds.backgroundColor = newColor;
            }
        });
        const barIndex = currentBarChart.data.labels.indexOf(chName);
        if (barIndex !== -1) {
            currentBarChart.data.datasets[0].backgroundColor[barIndex] = newColor;
        }
        historyChart.update('none');
        currentBarChart.update('none');
    }

    function toggleDarkMode() {
        const isDark = document.getElementById('darkModeToggle').checked;
        document.body.classList.toggle('dark-mode', isDark);
        const textColor = isDark ? '#e0e0e0' : '#666';
        const gridColor = isDark ? '#444' : '#ddd';
        [historyChart, currentBarChart].forEach(chart => {
            if (chart) {
                if(chart.options.scales.x) {
                    chart.options.scales.x.ticks.color = textColor;
                    chart.options.scales.x.grid.color = gridColor;
                }
                if(chart.options.scales.y) {
                    chart.options.scales.y.ticks.color = textColor;
                    chart.options.scales.y.grid.color = gridColor;
                }
                if(chart.options.plugins.legend) {
                    chart.options.plugins.legend.labels.color = textColor;
                }
                chart.update('none');
            }
        });
    }

    function initCharts() {
        historyChart = new Chart(ctxHistory, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false, 
                animation: false,
                interaction: { mode: 'index', intersect: false },
                scales: {
                    x: { title: { display: true, text: 'Sample' } },
                    y: { title: { display: true, text: 'Temp (Â°C)' } }
                },
                plugins: {
                    legend: { 
                        position: 'top', 
                        labels: { 
                            font: { family: 'monospace' },
                            filter: function(item, chart) {
                                const dataset = chart.datasets[item.datasetIndex];
                                if (dataset.isAnomalyHidden) return false;
                                return true; 
                            }
                        },
                        onClick: function(e, legendItem, legend) {
                            const index = legendItem.datasetIndex;
                            const dataset = legend.chart.data.datasets[index];
                            const chName = dataset.chName;
                            if (legend.chart.isDatasetVisible(index)) {
                                hiddenChannels.add(chName);
                            } else {
                                hiddenChannels.delete(chName);
                            }
                            Chart.defaults.plugins.legend.onClick.call(this, e, legendItem, legend);
                            updateChartWindow(); 
                            updateBarChart(lastReceivedData);
                        }
                    } 
                }
            }
        });

        currentBarChart = new Chart(ctxBar, {
            type: 'bar',
            data: { labels: [], datasets: [{ label: 'Temp', data: [], backgroundColor: [], borderWidth: 1 }] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } }
            }
        });
        toggleDarkMode();
    }
    initCharts();

    navigator.serial.addEventListener("disconnect", (event) => {
        if (port && event.target === port) closeConnection(true);
    });

    document.getElementById('connectBtn').addEventListener('click', async () => {
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 115200 });
            const textDecoder = new TextDecoderStream();
            inputDone = port.readable.pipeTo(textDecoder.writable);
            reader = textDecoder.readable.getReader();
            const textEncoder = new TextEncoderStream();
            outputDone = textEncoder.readable.pipeTo(port.writable);
            writer = textEncoder.writable.getWriter();
            updateUIState(true);
            readLoop();
        } catch (err) { alert('é€£ç·šå¤±æ•—: ' + err); }
    });

    document.getElementById('disconnectBtn').addEventListener('click', () => closeConnection(false));

    async function closeConnection(isPhysical) {
        if (!isConnected) return;
        if (reader) await reader.cancel().catch(()=>{});
        if (writer) { await writer.close().catch(()=>{}); writer = null; }
        if (inputDone) await inputDone.catch(()=>{});
        if (outputDone) await outputDone.catch(()=>{});
        if (port) { await port.close().catch(()=>{}); port = null; }
        updateUIState(false);
        if(isPhysical) alert("âš ï¸ ç·šè·¯æ–·é–‹ï¼");
    }

    async function readLoop() {
        let buffer = "";
        try {
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                    buffer += value;
                    let lines = buffer.split('\n');
                    buffer = lines.pop(); 
					for (let line of lines) {
                        let trimmedLine = line.trim();
                        if (trimmedLine) {
                            // ã€æ–°å¢é€™è¡Œã€‘ç´€éŒ„æ¥æ”¶åˆ°çš„åŸå§‹æ•¸æ“š
                            appendLog("RX", trimmedLine);
                            
                            processData(trimmedLine);
                        }
					}	
                }
            }
        } catch (e) { console.warn(e); } 
        finally { if(reader) reader.releaseLock(); }
    }

    function updateUIState(connected) {
        isConnected = connected;
        document.getElementById('status').innerText = connected ? "âœ… å·²é€£ç·š" : "âŒ æœªé€£ç·š";
        document.getElementById('status').className = connected ? "status-badge status-connected" : "status-badge status-disconnected";
        document.getElementById('connectBtn').disabled = connected;
        document.getElementById('disconnectBtn').disabled = !connected;
        document.getElementById('btn_set_all').disabled = !connected;
        document.getElementById('btn_disable_all').disabled = !connected; 
        document.querySelectorAll('.btn-row-set').forEach(btn => btn.disabled = !connected);
		
		const btnSetAllLTC = document.getElementById('btn_set_all_ltc');
        if(btnSetAllLTC) btnSetAllLTC.disabled = !connected;

        const btnDisableAllLTC = document.getElementById('btn_disable_all_ltc');
        if(btnDisableAllLTC) btnDisableAllLTC.disabled = !connected;

        // æ§åˆ¶æ¯ä¸€åˆ— LTC çš„ Set æŒ‰éˆ• (éœ€æ­é…ç¬¬ä¸‰æ­¥ä¿®æ”¹ class)
        document.querySelectorAll('.btn-ltc-row-set').forEach(btn => btn.disabled = !connected);
    }

	// [æ–°å¢] è¼”åŠ©å‡½å¼ï¼šå°‡æ•¸æ“šå­˜å…¥å…¨åŸŸè®Šæ•¸
    function saveToGlobalData(key, value) {
        if (!globalData.channels[key]) {
            // å¦‚æœæ˜¯æ–°é€šé“ï¼Œè‡ªå‹•è£œé½Šå‰é¢ç¼ºå°‘çš„é»æ•¸
            let missingCount = globalData.labels.length - 1;
            if(missingCount < 0) missingCount = 0; 
            globalData.channels[key] = new Array(missingCount).fill(null);
        }
        globalData.channels[key].push(value);
    }
	
	// ç”¨ä¾†è¨˜éŒ„å·²ç¶“ç”¢ç”Ÿé Input çš„é€šé“ï¼Œé¿å…é‡è¤‡ç”¢ç”Ÿ
    let renderedChannels = new Set();

    // [æ–°å¢] æ¸²æŸ“é¡è‰²è¨­å®šä»‹é¢
   // [ä¿®æ”¹] æ¸²æŸ“é¡è‰²è¨­å®šä»‹é¢ (åŒ…å«æ›´è°æ˜çš„æ’åº)
    function renderColorInputs() {
        const containerTMP = document.getElementById('containerTMP');
        const containerLTC = document.getElementById('containerLTC');
        
        if (!containerTMP || !containerLTC) return;

        // å–å¾—æ‰€æœ‰é€šé“ä¸¦æ’åº
        const channels = Object.keys(globalData.channels).sort((a, b) => {
            // 1. æ¯”è¼ƒé¡å‹ (TMP æ’å‰é¢)
            const isLtca = a.startsWith('LTC');
            const isLtcb = b.startsWith('LTC');
            if (isLtca !== isLtcb) return isLtca ? 1 : -1; // TMP first

            // 2. åŒé¡å‹æ¯”è¼ƒæ•¸å­—
            if (!isLtca) { 
                // éƒ½æ˜¯ TMP117_CHx
                const numA = parseInt(a.replace('TMP117_CH', '')) || 0;
                const numB = parseInt(b.replace('TMP117_CH', '')) || 0;
                return numA - numB;
            } else {
                // éƒ½æ˜¯ LTC_x_y -> å…ˆæ¯” x (Device)ï¼Œå†æ¯” y (Channel)
                const partsA = a.split('_').map(Number); // [NaN, 1, 1]
                const partsB = b.split('_').map(Number);
                
                // æ¯” Device ID (index 1)
                if (partsA[1] !== partsB[1]) return partsA[1] - partsB[1];
                // æ¯” Channel ID (index 2)
                return partsA[2] - partsB[2];
            }
        });

        channels.forEach(chName => {
            if (renderedChannels.has(chName)) return;

            let color = getChannelColor(chName);
            if (color.startsWith('hsl')) color = hslToHexStr(color);

            const div = document.createElement('div');
            div.className = 'color-item';
            div.innerHTML = `
                <label for="cp_${chName}">${chName}</label>
                <input type="color" id="cp_${chName}" value="${color}">
            `;

            const input = div.querySelector('input');
            input.addEventListener('change', (e) => {
                channelColors[chName] = e.target.value;
                localStorage.setItem('stm32_channel_colors', JSON.stringify(channelColors));
                updateChartWindow();
            });

            // åˆ†é¡æ”¾å…¥å°æ‡‰å®¹å™¨
            if (chName.startsWith('LTC')) {
                containerLTC.appendChild(div);
            } else {
                containerTMP.appendChild(div);
            }

            renderedChannels.add(chName);
        });
    }

    // [è¼”åŠ©] è§£æ hsl(h, s%, l%) å­—ä¸²ä¸¦è½‰ç‚º Hex
    function hslToHexStr(hslStr) {
        // ç°¡æ˜“è§£æ: hsl(30, 100%, 50%)
        const sep = hslStr.indexOf(",") > -1 ? "," : " ";
        hslStr = hslStr.substr(4).split(")")[0].split(sep);
        
        let h = parseInt(hslStr[0]);
        let s = parseInt(hslStr[1].replace('%','')) / 100;
        let l = parseInt(hslStr[2].replace('%','')) / 100;

        let c = (1 - Math.abs(2 * l - 1)) * s;
        let x = c * (1 - Math.abs((h / 60) % 2 - 1));
        let m = l - c / 2;
        let r = 0, g = 0, b = 0;

        if (0 <= h && h < 60) { r = c; g = x; b = 0; }
        else if (60 <= h && h < 120) { r = x; g = c; b = 0; }
        else if (120 <= h && h < 180) { r = 0; g = c; b = x; }
        else if (180 <= h && h < 240) { r = 0; g = x; b = c; }
        else if (240 <= h && h < 300) { r = x; g = 0; b = c; }
        else if (300 <= h && h < 360) { r = c; g = 0; b = x; }

        r = Math.round((r + m) * 255).toString(16).padStart(2, '0');
        g = Math.round((g + m) * 255).toString(16).padStart(2, '0');
        b = Math.round((b + m) * 255).toString(16).padStart(2, '0');

        return `#${r}${g}${b}`;
    }
	
	function processData(line) {
        if (!line.startsWith('{')) return;
        if (isBulkDisabling) return;
        
        try {
            const json = JSON.parse(line);
            const tmpData = json.TMP117 || json.data;
            const ltcData = json.LTC2983;

            if ((!tmpData || tmpData.length === 0) && (!ltcData || ltcData.length === 0)) return;

            globalSampleCount++;
            globalData.labels.push(globalSampleCount);
			
            // â–¼â–¼â–¼ [æœ€çµ‚ä¿®æ­£ç‰ˆ V3] è‡ªå‹• CSV å­˜æª” (ä¿®å¾©è³‡æ–™è¦†è“‹èˆ‡æ™‚é–“æ ¼å¼) â–¼â–¼â–¼
            
            // 1. ç”¢ç”Ÿæ™‚é–“å­—ä¸² (æ”¹ç”¨æ–œç·šï¼ŒExcel æ”¯æ´åº¦è¼ƒå¥½)
            const csvNow = new Date();
            const timeStr = csvNow.getFullYear() + "/" +
                            (csvNow.getMonth() + 1).toString().padStart(2, '0') + "/" +
                            csvNow.getDate().toString().padStart(2, '0') + " " +
                            csvNow.getHours().toString().padStart(2, '0') + ":" +
                            csvNow.getMinutes().toString().padStart(2, '0') + ":" +
                            csvNow.getSeconds().toString().padStart(2, '0') + "." +
                            csvNow.getMilliseconds().toString().padStart(3, '0');

            // 2. æå–æ•¸æ“š (ä¿®å¾©æ¬„ä½åç¨±ï¼Œé¿å… Multiplexer è³‡æ–™äº’ç›¸è¦†è“‹)
            let csvRowData = {};

            // (A) è™•ç† TMP117
            if (tmpData && Array.isArray(tmpData)) {
                tmpData.forEach(item => {
                    // [é‡é»ä¿®å¾©] å„ªå…ˆä½¿ç”¨ Channel (c) ç•¶ä½œ Keyï¼Œé¿å…åŒ Address è¦†è“‹
                    // å¦‚æœæœ‰ item.c (å¤šå·¥å™¨é€šé“)ï¼Œå°±ç”¨ TMP117_CHx
                    if (item.c !== undefined) {
                        csvRowData[`TMP117_CH${item.c}`] = item.v;
                    } 
                    // å¦‚æœæ²’æœ‰ c åªæœ‰ a (ç›´é€£)ï¼Œæ‰ç”¨ T_Addr_x
                    else if (item.a !== undefined) {
                        csvRowData[`T_Addr_${item.a}`] = item.v;
                    }
                });
            }

            // (B) è™•ç† LTC2983
            if (ltcData && Array.isArray(ltcData)) {
                ltcData.forEach(item => {
                    // æ ¼å¼æ”¹å›æ‚¨ç¿’æ…£çš„: LTC_1_5 (Device_Channel)
                    let dev = item.d || 1; 
                    if (item.c !== undefined && item.v !== undefined) {
                        csvRowData[`LTC_${dev}_${item.c}`] = item.v;
                    }
                });
            }

            // 3. é€å…¥è‡ªå‹•å­˜æª”ç³»çµ±
            if (typeof handleAutoSave === 'function') {
                handleAutoSave(timeStr, csvRowData);
            }
            
            // â–²â–²â–² [ä¿®æ­£çµæŸ] â–²â–²â–²
			
            let receivedKeys = new Set();

            // =========================================================
            // 1. è™•ç† TMP117 -> å‘½åæ”¹ç‚º TMP117_CHx
            // =========================================================
            if (tmpData && tmpData.length > 0) {
                lastReceivedData = tmpData; 
                
                tmpData.forEach((item) => {
                    // [ä¿®æ”¹] åŠ ä¸Šå‰ç¶´
                    let chKey = `TMP117_CH${item.c}`; 
                    receivedKeys.add(chKey);
                    let currentVal = item.v;

                    // æ­»é–åµæ¸¬
                    let lastState = channelStuckCounts[chKey] || { lastVal: null, count: 0 };
                    if (currentVal === lastState.lastVal && currentVal !== 0) {
                        lastState.count++;
                    } else {
                        lastState.count = 0;
                        lastState.lastVal = currentVal;
                    }
                    channelStuckCounts[chKey] = lastState;

                    saveToGlobalData(chKey, currentVal);
                    
                    if (item.a !== undefined) {
                        let hexAddr = item.a.toString(16).toUpperCase();
                        channelAddressMap[chKey] = `0x${hexAddr}`;
                    }
                });
            }

            // =========================================================
            // 2. è™•ç† LTC2983 -> å‘½åæ”¹ç‚º LTC_1_x (é è¨­ Device 1)
            // =========================================================
            if (ltcData && ltcData.length > 0) {
                ltcData.forEach((item) => {
					
					let devId = item.d || 1; 
                    let chId = item.c;                    
                    // çµ„åˆåç¨±ï¼šLTC_1_1, LTC_2_1...
                    let chKey = `LTC_${devId}_${chId}`;

                    receivedKeys.add(chKey);
                    let currentVal = item.v;

                    // æ­»é–åµæ¸¬
                    let lastState = channelStuckCounts[chKey] || { lastVal: null, count: 0 };
                    if (currentVal === lastState.lastVal && currentVal !== 0) {
                        lastState.count++;
                    } else {
                        lastState.count = 0;
                        lastState.lastVal = currentVal;
                    }
                    channelStuckCounts[chKey] = lastState;

                    saveToGlobalData(chKey, currentVal);
                });
            }

            // =========================================================
            // 3. è³‡æ–™å°é½Š & Buffer ç®¡ç† (ä¸è®Š)
            // =========================================================
            Object.keys(globalData.channels).forEach(existingKey => {
                if (!receivedKeys.has(existingKey)) {
                    globalData.channels[existingKey].push(null);
                }
            });

            if (globalData.labels.length > MAX_STORED_POINTS) {
                globalData.labels.shift();
                Object.values(globalData.channels).forEach(arr => arr.shift());
            }

            updateScrollbarState();
            updateChartWindow();
            
            // æª¢æŸ¥æ˜¯å¦éœ€è¦æ–°å¢é¡è‰²è¨­å®š
            renderColorInputs();
            
            // æ›´æ–°é•·æ¢åœ– (åˆä½µæ•¸æ“š)
            const barChartPayload = [];
            if (tmpData) tmpData.forEach(i => barChartPayload.push({ key: `TMP117_CH${i.c}`, val: i.v }));
            if (ltcData) ltcData.forEach(i => barChartPayload.push({ key: `LTC_1_${i.c}`, val: i.v }));
            
            if (typeof updateBarChart === 'function') {
                updateBarChart(barChartPayload);
            }

        } catch (e) { console.warn("Parse Error:", e); }
    }

    function updateScrollbarState() {
        const scrollBar = document.getElementById('historyScroll');
        const infoSpan = document.getElementById('scrollInfo');
        const totalPoints = globalData.labels.length;
        
        let maxScroll = Math.max(0, totalPoints - VIEW_WINDOW_SIZE);
        scrollBar.max = maxScroll;

        if (isAutoScroll) scrollBar.value = maxScroll;

        if (totalPoints <= VIEW_WINDOW_SIZE) {
            scrollBar.disabled = true;
            infoSpan.innerText = `Buffering: ${totalPoints}/${VIEW_WINDOW_SIZE}`;
            infoSpan.style.color = document.body.classList.contains('dark-mode') ? '#777' : '#666';
        } else {
            scrollBar.disabled = false;
            if (isAutoScroll) {
                infoSpan.innerText = "Auto Tracking";
                infoSpan.style.color = "green";
            } else {
                let currentVal = parseInt(scrollBar.value);
                infoSpan.innerText = `History: -${maxScroll - currentVal}`;
                infoSpan.style.color = "#dc3545"; 
            }
        }
    }

   function updateBarChart(dataItems) {
        if (!currentBarChart) return;
        
        // å¦‚æœæ²’æœ‰æ•¸æ“šï¼Œæ¸…ç©ºåœ–è¡¨
        if (!dataItems || dataItems.length === 0) {
            currentBarChart.data.labels = [];
            currentBarChart.data.datasets[0].data = [];
            currentBarChart.update('none');
            return;
        }

        const labels = [];
        const values = [];
        const colors = [];
        
        // å–å¾—ç•°å¸¸éæ¿¾è¨­å®š
        const filterAnomalies = document.getElementById('filterAnomalies') ? document.getElementById('filterAnomalies').checked : false;

        dataItems.forEach(item => {
            // [ä¿®æ­£] ç›´æ¥ä½¿ç”¨ processData å‚³ä¾†çš„å®Œæ•´åç¨± (key) èˆ‡æ•¸å€¼ (val)
            let chName = item.key; 
            let val = item.val;

			<!-- if (val <= -273.0) return; -->
            // 1. å¦‚æœä½¿ç”¨è€…æ‰‹å‹•éš±è—äº†è©²é€šé“ï¼Œè·³é
            if (hiddenChannels.has(chName)) return;

            // 2. å¦‚æœé–‹å•Ÿäº†ç•°å¸¸éæ¿¾ï¼Œä¸”æ•¸å€¼ç•°å¸¸ï¼Œè·³é
            if (filterAnomalies && checkAnomaly(val)) return;

            // 3. åŠ å…¥é¡¯ç¤ºåˆ—è¡¨
            labels.push(chName);
            values.push(val);
            
            // 4. è‡ªå‹•å–å¾—å°æ‡‰é¡è‰² (CHç‚ºå†·è‰²ï¼ŒLTCç‚ºæš–è‰²)
            colors.push(getChannelColor(chName));
        });

        // æ›´æ–° Chart.js æ•¸æ“š
        currentBarChart.data.labels = labels;
        currentBarChart.data.datasets[0].data = values;
        currentBarChart.data.datasets[0].backgroundColor = colors;
        currentBarChart.data.datasets[0].borderColor = colors;

        // ä½¿ç”¨ç„¡å‹•ç•«æ¨¡å¼æ›´æ–°
        currentBarChart.update('none');
    }

    window.onScrollChange = function() {
        const scrollBar = document.getElementById('historyScroll');
        const maxScroll = parseInt(scrollBar.max);
        const currentVal = parseInt(scrollBar.value);
        if (currentVal >= maxScroll) isAutoScroll = true;
        else isAutoScroll = false;
        updateScrollbarState();
        updateChartWindow();
    }
	// ã€æ–°å¢åŠŸèƒ½ã€‘æ‰¹é‡å¥—ç”¨ Address
    function applyBatchAddr() {
        const val = document.getElementById('batchAddrSelect').value;
        const selects = document.querySelectorAll('#configRowsContainer .row-addr-select');
        
        if (selects.length === 0) {
            alert("æ²’æœ‰å¯ä¿®æ”¹çš„é…ç½®åˆ—ï¼");
            return;
        }

        selects.forEach(select => {
            select.value = val;
        });
        
        saveConfigRows(); // å„²å­˜è®Šæ›´
        // alert("å·²æ›´æ–°æ‰€æœ‰ Addressï¼Œè«‹æŒ‰ Set All ç™¼é€æŒ‡ä»¤ã€‚"); // (é¸æ“‡æ€§æç¤º)
    }
	
	// --- Log Functions ---
    function appendLog(type, msg) {
        // æª¢æŸ¥æ˜¯å¦å‹¾é¸ç´€éŒ„
        const isLogging = document.getElementById('enableLogging').checked;
        if (!isLogging) return;

        const logArea = document.getElementById('commLogArea');
        const now = new Date();
        const timeStr = now.toLocaleTimeString('zh-TW', { hour12: false }) + "." + String(now.getMilliseconds()).padStart(3, '0');
        
        // TX (ç™¼é€) ç”¨é»ƒè‰²ï¼ŒRX (æ¥æ”¶) ç”¨ç¶ è‰²/ç™½è‰²
        const color = type === 'TX' ? '#ffeb3b' : '#a6e22e'; // Yellow for TX, Green for RX
        const icon = type === 'TX' ? 'ğŸ“¤' : 'ğŸ“¥';
        
        const div = document.createElement('div');
        div.style.borderBottom = "1px solid #333";
        div.innerHTML = `<span style="color:#888;">[${timeStr}]</span> <span style="color:${color}; font-weight:bold;">${icon} ${type}:</span> <span style="color:#ddd;">${msg}</span>`;
        
		logArea.appendChild(div);

        while (logArea.children.length > MAX_LOG_LINES) {
            logArea.removeChild(logArea.firstChild);
        }

        logArea.scrollTop = logArea.scrollHeight;
    }

    function clearLog() {
        document.getElementById('commLogArea').innerHTML = '';
    }
	
    function updateChartWindow() {
        const scrollBar = document.getElementById('historyScroll');
        let startIndex = parseInt(scrollBar.value);
        let endIndex = startIndex + VIEW_WINDOW_SIZE;

        let viewLabels = globalData.labels.slice(startIndex, endIndex);
        let viewDatasets = [];
        let currentFrameMin = Infinity;
        let currentFrameMax = -Infinity;

        let dynamicRadius = (viewLabels.length <= 1) ? 5 : 1;
        let errorChannels = [];
        const filterAnomalies = document.getElementById('filterAnomalies').checked;

        Object.keys(globalData.channels).forEach((chName) => {
            let fullData = globalData.channels[chName];
            let slicedData = fullData.slice(startIndex, endIndex);
			
			let plotData = slicedData.map(v => {
                if (v === null) return null;
				<!-- if (v <= -273.0) return null; -->
                if (checkAnomaly(v)) {
                    // é€™è£¡åªè² è²¬æ¿¾æ‰åœ–è¡¨ä¸Šçš„é»ï¼Œä¸å†è§¸ç™¼ç´…æ¢è­¦å‘Š
                    return filterAnomalies ? null : v;
                }
                return v;
            });


            let latestLiveVal = null;
            for(let i=fullData.length-1; i>=0; i--) {
                <!-- if(fullData[i] !== null&& fullData[i] > -273.0) { latestLiveVal = fullData[i]; break; } -->
                if(fullData[i] !== null) { latestLiveVal = fullData[i]; break; }

            }
			
			// ã€æ–°å¢ã€‘åœ¨è¿´åœˆå¤–ï¼Œåªæª¢æŸ¥ã€Œæœ€æ–°ä¸€ç­†ã€æ•¸å€¼
            // å¦‚æœæœ€æ–°å€¼æ˜¯ç•°å¸¸çš„ï¼Œæ‰åŠ å…¥éŒ¯èª¤åˆ—è¡¨
            if (latestLiveVal !== null && checkAnomaly(latestLiveVal)) {
                if (!errorChannels.includes(chName)) errorChannels.push(chName);
            }
            
            let isAutoHidden = false;
            if (filterAnomalies && latestLiveVal !== null && checkAnomaly(latestLiveVal)) {
                isAutoHidden = true;
            }

            let isManualHidden = hiddenChannels.has(chName);
            
            let isStuck = false;
            // æª¢æŸ¥æ˜¯å¦è¶…éé–¾å€¼ (ä½¿ç”¨ script é–‹é ­å®šç¾©çš„ channelStuckCounts)
            if (channelStuckCounts[chName] && channelStuckCounts[chName].count > stuckThreshold) {
                isStuck = true;
            }
			
            let labelText = chName; 
            const showAddr = document.getElementById('showAddrToggle').checked;
            if (showAddr && channelAddressMap[chName]) {
                labelText += ` (${channelAddressMap[chName]})`;
            }

            if (latestLiveVal !== null) {
                labelText += `: ${latestLiveVal.toFixed(2)}Â°C`;
            }
            
            if (!isManualHidden && !isAutoHidden) {
                plotData.forEach(v => {
                    if (v !== null) {
                        if (v < currentFrameMin) currentFrameMin = v;
                        if (v > currentFrameMax) currentFrameMax = v;
                    }
                });
            }		
            
			// è¨­å®šé¡è‰²èˆ‡ç·šæ¢æ¨£å¼
            let color = getChannelColor(chName);
            let borderDash = []; // é è¨­å¯¦ç·š

            // å¦‚æœåˆ¤å®šç‚ºå¡æ­»/æ–·ç·šï¼Œå¼·åˆ¶æ”¹è®Šé¡è‰²èˆ‡æ¨£å¼
            if (isStuck) {
                color = '#999999';           // è®Šæˆç°è‰²
                borderDash = [5, 5];         // è®Šæˆè™›ç·š
                labelText += " [æ–·ç·š/NO SIGNAL]"; // åŠ è¨»è­¦èª
            }
            <!-- let color = getChannelColor(chName); -->

            viewDatasets.push({
                chName: chName, 
                label: labelText,
                data: plotData, 
                borderColor: color,
                backgroundColor: color,
                borderWidth: 2,
				borderDash: borderDash,   // å¥—ç”¨è™›ç·š
                tension: 0.1,
                pointRadius: dynamicRadius, 
                pointHoverRadius: 6,
                spanGaps: false, 
                hidden: isManualHidden,
                isAnomalyHidden: isAutoHidden
            });
        });

        const errorBanner = document.getElementById('errorBanner');
        const errorMessage = document.getElementById('errorMessage');
        if (errorChannels.length > 0) {
            errorBanner.style.display = 'flex';
            let uniqueErrors = [...new Set(errorChannels)];
            errorMessage.textContent = `åµæ¸¬åˆ°ç•°å¸¸: ${uniqueErrors.join(', ')}`;
        } else {
            errorBanner.style.display = 'none';
        }

        historyChart.data.labels = viewLabels;
        historyChart.data.datasets = viewDatasets;

        const autoScale = document.getElementById('autoScale').checked;
        if (autoScale && currentFrameMin !== Infinity) {
            historyChart.options.scales.y.min = currentFrameMin - 0.1;
            historyChart.options.scales.y.max = currentFrameMax + 0.1;
        } else if (!autoScale) {
            historyChart.options.scales.y.min = parseFloat(document.getElementById('yMin').value);
            historyChart.options.scales.y.max = parseFloat(document.getElementById('yMax').value);
        }
        historyChart.update('none');
    }


    // ===========================================
    //   LTC2983 Configuration Logic (New)
    // ===========================================

    // 1. è¼‰å…¥è¨­å®š (å·²å‡ç´š: å‚³é params)
    function loadLTCConfigRows() {
        const saved = localStorage.getItem('stm32_ltc_config_rows');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                if (Array.isArray(data) && data.length > 0) {
                    // [ä¿®æ”¹] å‚³å…¥ item.params
                    data.forEach(item => addLTCConfigRow(item.dev, item.ch, item.type, item.params));
                    return;
                }
            } catch (e) {}
        }
        // é è¨­åŠ ä¸€åˆ—
        addLTCConfigRow(1, 1, 0);
    }

   // 2. å„²å­˜è¨­å®š (å·²å‡ç´š: å„²å­˜æ‰€æœ‰é€²éšåƒæ•¸)
    function saveLTCConfigRows() {
        const rows = document.querySelectorAll('#ltcConfigRowsContainer .config-row');
        const dataToSave = [];
        
        rows.forEach(row => {
            // åŸºæœ¬åƒæ•¸
            const dev = row.querySelector('.row-dev-select').value;
            const ch = row.querySelector('.row-ch-select').value;
            const type = row.querySelector('.row-type-select').value;
            
            // é€²éšåƒæ•¸ (Params) - æŠŠæ¯å€‹æ¬„ä½éƒ½æŠ“å‡ºä¾†å­˜
            const params = {};
            
            // è¼”åŠ©å‡½å¼
            const getChk = (sel) => { const el = row.querySelector(sel); return el ? el.checked : false; };
            const getVal = (sel) => { const el = row.querySelector(sel); return el ? el.value : "0"; };

            // Thermocouple
            params.tc_se = getChk('.chk-tc-se');
            params.tc_oc = getChk('.chk-tc-oc');
            params.tc_curr = getVal('.sel-tc-curr');
            params.tc_cj = getVal('.sel-tc-cj');

            // Diode
            params.diode_se = getChk('.chk-diode-se');
            params.diode_3r = getChk('.chk-diode-3r');
            params.diode_avg = getChk('.chk-diode-avg');
            params.diode_curr = getVal('.sel-diode-curr');

            // RTD
            params.rtd_wires = getVal('.sel-rtd-wires');
            params.rtd_curr = getVal('.sel-rtd-curr');
            params.rtd_curve = getVal('.sel-rtd-curve');

            dataToSave.push({ dev, ch, type, params });
        });
        
        localStorage.setItem('stm32_ltc_config_rows', JSON.stringify(dataToSave));
    }

    // 3. æ–°å¢ä¸€åˆ— (LTC2983)
    function addLTCConfigRow(defDev = null, defCh = null, defType = null, defParams = null) {
        const container = document.getElementById('ltcConfigRowsContainer');
        const rowId = 'ltc-row-' + Date.now() + Math.random().toString(36).substr(2, 9);

        // è‡ªå‹•éå¢é‚è¼¯ (ä¿æŒä¸è®Š)
        if (defDev === null) {
            const rows = container.querySelectorAll('.row-ch-select');
            if (rows.length > 0) {
                const lastRow = rows[rows.length-1].closest('.config-row');
                defDev = lastRow.querySelector('.row-dev-select').value;
                let lastCh = parseInt(lastRow.querySelector('.row-ch-select').value);
                defCh = (lastCh % 20) + 1; 
                defType = lastRow.querySelector('.row-type-select').value;
            } else { 
                defDev = 1; defCh = 1; defType = 0; 
            }
        }

        // ç”¢ç”Ÿå†·æ¥é»é¸é …çš„è¼”åŠ©å‡½å¼
        const generateCJOptions = () => {
            let opts = '<option value="0">None</option>';
            for(let i=1; i<=20; i++) {
                opts += `<option value="${i}" ${i==20?'selected':''}>Ch ${i}</option>`;
            }
            return opts;
        };

        const div = document.createElement('div');
        div.className = 'config-row';
        div.id = rowId;
        
        div.innerHTML = `
            <div style="display:flex; align-items:center; gap:5px; flex-wrap:wrap;">
                <label>Device: 
                    <select class="row-dev-select" style="width:40px;">
                        <option value="1" ${defDev==1?'selected':''}>1</option>
                        <option value="2" ${defDev==2?'selected':''}>2</option>
                    </select>
                </label>
                <label>CH: 
                    <select class="row-ch-select" style="width:45px;">
                        ${generateLTCChannelOptions(defCh)}
                    </select>
                </label>
                <label>Type:
                    <select class="row-type-select" onchange="updateRowParams('${rowId}'); updateConfigHexPreview('${rowId}')" style="width: auto; min-width: 120px; max-width: 200px;">
                        ${generateLTCTypeOptions(defType)}
                    </select>
                </label>

                <div id="params-${rowId}" class="params-container" style="visibility:hidden;">
                    
                    <span class="p-tc" style="display:none; align-items:center; gap:12px;">
                        <label class="param-label" title="Single-Ended Mode"><input type="checkbox" class="chk-tc-se" checked onchange="updateConfigHexPreview('${rowId}')">Single-Ended</label>
                        <label class="param-label" title="Open Circuit Detection"><input type="checkbox" class="chk-tc-oc" checked onchange="updateConfigHexPreview('${rowId}')">Open Ckt Detect</label>
                        
                        <div style="display:flex; align-items:center; gap:2px;">
                            <span style="font-size:11px; color:#aaa;">OC Curr:</span>
                            <select class="sel-tc-curr" onchange="updateConfigHexPreview('${rowId}')" style="font-size:12px; padding:0;">
                                <option value="0">10uA</option><option value="1">100uA</option><option value="2">500uA</option><option value="3">1mA</option>
                            </select>
                        </div>
                        
                        <div style="display:flex; align-items:center; gap:2px; border-left:1px solid #666; padding-left:8px; margin-left:4px;">
                            <span style="font-size:11px; color:#aaa;">Cold Junc:</span>
                            <select class="sel-tc-cj" onchange="updateConfigHexPreview('${rowId}')" style="font-size:12px; width:60px; padding:0;">
                                ${generateCJOptions()}
                            </select>
                        </div>
                    </span>

                    <span class="p-diode" style="display:none; align-items:center; gap:12px;">
                        <label class="param-label" title="Single-Ended Mode"><input type="checkbox" class="chk-diode-se" checked onchange="updateConfigHexPreview('${rowId}')">Single-Ended</label>
                        <label class="param-label" title="Three Reading Mode"><input type="checkbox" class="chk-diode-3r" checked onchange="updateConfigHexPreview('${rowId}')">3-Reading</label>
                        <label class="param-label" title="Average Mode"><input type="checkbox" class="chk-diode-avg" checked onchange="updateConfigHexPreview('${rowId}')">Average</label>
                        
                        <div style="display:flex; align-items:center; gap:2px;">
                            <span style="font-size:11px; color:#aaa;">Curr:</span>
                            <select class="sel-diode-curr" onchange="updateConfigHexPreview('${rowId}')" style="font-size:12px; padding:0;">
                                <option value="0">10uA</option><option value="1" selected>20uA</option><option value="2">40uA</option><option value="3">80uA</option>
                            </select>
                        </div>
                    </span>

                    <span class="p-rtd" style="display:none; align-items:center; gap:10px;">
                        <select class="sel-rtd-wires" onchange="updateConfigHexPreview('${rowId}')" style="font-size:12px; padding:0;">
                            <option value="0">2-Wire</option><option value="1">3-Wire</option><option value="2">4-Wire</option><option value="3">4-Wire Kelvin</option>
                        </select>
                        <select class="sel-rtd-curr" onchange="updateConfigHexPreview('${rowId}')" style="font-size:12px; padding:0;">
                            <option value="2">10uA</option><option value="4">50uA</option><option value="6" selected>100uA</option><option value="8">500uA</option><option value="12">1mA</option>
                        </select>
                        <select class="sel-rtd-curve" onchange="updateConfigHexPreview('${rowId}')" style="font-size:12px; padding:0;">
                            <option value="0">European</option><option value="1">American</option><option value="2">Japanese</option><option value="3">ITS-90</option>
                        </select>
                    </span>

                    <span id="hex-${rowId}" class="hex-preview" style="margin-left:auto;">0x00</span>
                </div>

                <button class="btn-config btn-ltc-row-set" onclick="setSingleLTCRow('${rowId}')" ${isConnected ? '' : 'disabled'} style="background:#17a2b8;">Set</button>            
                <button class="btn-remove" onclick="removeLTCConfigRow('${rowId}')">-</button>
            </div>
        `;
        
		// =========================================================
        // [æ–°å¢] é‚„åŸé€²éšåƒæ•¸ (å¦‚æœæœ‰çš„è©±)
        // =========================================================
        if (defParams) {
            const setChk = (sel, val) => { const el = div.querySelector(sel); if(el) el.checked = val; };
            const setVal = (sel, val) => { const el = div.querySelector(sel); if(el) el.value = val; };

            // Thermocouple
            if (defParams.tc_se !== undefined) setChk('.chk-tc-se', defParams.tc_se);
            if (defParams.tc_oc !== undefined) setChk('.chk-tc-oc', defParams.tc_oc);
            if (defParams.tc_curr !== undefined) setVal('.sel-tc-curr', defParams.tc_curr);
            if (defParams.tc_cj !== undefined) setVal('.sel-tc-cj', defParams.tc_cj);

            // Diode
            if (defParams.diode_se !== undefined) setChk('.chk-diode-se', defParams.diode_se);
            if (defParams.diode_3r !== undefined) setChk('.chk-diode-3r', defParams.diode_3r);
            if (defParams.diode_avg !== undefined) setChk('.chk-diode-avg', defParams.diode_avg);
            if (defParams.diode_curr !== undefined) setVal('.sel-diode-curr', defParams.diode_curr);

            // RTD
            if (defParams.rtd_wires !== undefined) setVal('.sel-rtd-wires', defParams.rtd_wires);
            if (defParams.rtd_curr !== undefined) setVal('.sel-rtd-curr', defParams.rtd_curr);
            if (defParams.rtd_curve !== undefined) setVal('.sel-rtd-curve', defParams.rtd_curve);
        }
		
        container.appendChild(div);
        updateRowParams(rowId);
        updateConfigHexPreview(rowId); // åˆå§‹åŒ–è¨ˆç®—
        
        div.querySelectorAll('select, input').forEach(s => s.addEventListener('change', saveLTCConfigRows));
        saveLTCConfigRows();
    }
	
	// [æ–°å¢] æ ¹æ“šé¸æ“‡çš„ Typeï¼Œé¡¯ç¤º/éš±è—å°æ‡‰çš„åƒæ•¸è¨­å®š
    function updateRowParams(rowId) {
        const row = document.getElementById(rowId);
        if (!row) return;

        const typeSelect = row.querySelector('.row-type-select');
        const val = parseInt(typeSelect.value);

        // å–å¾—ä¸‰å€‹å€åŸŸ
        const pTC = row.querySelector('.p-tc');
        const pDiode = row.querySelector('.p-diode');
        const pRTD = row.querySelector('.p-rtd');
        const container = row.querySelector('.params-container');

        // å…ˆå…¨éƒ¨éš±è—
        pTC.style.display = 'none';
        pDiode.style.display = 'none';
        pRTD.style.display = 'none';
        container.style.visibility = 'visible'; // é è¨­é¡¯ç¤ºå®¹å™¨

        // åˆ¤æ–·é‚è¼¯ (ä¾æ“š Datasheet å®šç¾©)
        if (val >= 1 && val <= 9) {
            // Thermocouple (Type 1~9)
            pTC.style.display = 'flex';
        } 
        else if (val >= 10 && val <= 18) {
            // RTD (Type 10~18)
            pRTD.style.display = 'flex';
        }
        else if (val === 28) {
            // Diode (Type 28)
            pDiode.style.display = 'flex';
        }
        else {
            // NONE or Other -> éš±è—æ•´å€‹å®¹å™¨è®“ç•«é¢ä¹¾æ·¨
            container.style.visibility = 'hidden';
        }
    }
	
    // è¼”åŠ©: ç”¢ç”Ÿ 1~20 çš„é¸é …
    function generateLTCChannelOptions(selected) {
        let opts = '';
        for(let i=1; i<=20; i++) {
            opts += `<option value="${i}" ${i==selected ? 'selected' : ''}>${i}</option>`;
        }
        return opts;
    }

    // 4. ç§»é™¤ä¸€åˆ—
    function removeLTCConfigRow(rowId) {
        const row = document.getElementById(rowId);
        if (row) {
            row.remove();
            saveLTCConfigRows();
        }
    }
	
	async function setSingleLTCRow(rowId) {
        const row = document.getElementById(rowId);
        if (!row) return;

        const dev = row.querySelector('.row-dev-select').value;
        const ch = row.querySelector('.row-ch-select').value;
        const type = parseInt(row.querySelector('.row-type-select').value);

        // ============================================
        // è¨ˆç®— Config Word (å°æ‡‰ C èªè¨€ Macros)
        // ============================================
        let configWord = 0;

        if (type === 28) { // Diode
            // è®€å– Checkbox ç‹€æ…‹
            const isSE = row.querySelector('.chk-diode-se').checked;
            const is3Read = row.querySelector('.chk-diode-3r').checked;
            const isAvg = row.querySelector('.chk-diode-avg').checked;
            const currIdx = parseInt(row.querySelector('.sel-diode-curr').value);

            // Bit 26: Single-Ended
            if (isSE) configWord |= (1 << 26);
            // Bit 25: 3-Reading
            if (is3Read) configWord |= (1 << 25);
            // Bit 24: Average
            if (isAvg) configWord |= (1 << 24);
            // Bits 23-22: Excitation Current
            configWord |= (currIdx << 22);
        }
        else if (type >= 1 && type <= 9) { // Thermocouple
            const isSE = row.querySelector('.chk-tc-se').checked;
            const isOC = row.querySelector('.chk-tc-oc').checked;
            
            // Bit 26: Single-Ended
            if (isSE) configWord |= (1 << 26);
            // Bit 23: Open Circuit Detect
            if (isOC) configWord |= (1 << 23);
            // é è¨­ OC Current 10uA (00) -> é€™è£¡æ²’åšé¸é …ï¼Œé è¨­ç‚º 0
        }
        else if (type >= 10 && type <= 18) { // RTD
            const wires = parseInt(row.querySelector('.sel-rtd-wires').value);
            const curr = parseInt(row.querySelector('.sel-rtd-curr').value);
            const curve = parseInt(row.querySelector('.sel-rtd-curve').value);

            // Bits 21-20: Num Wires
            configWord |= (wires << 20);
            // Bits 19-18: Rotation (é è¨­ 0: No Rotation)
            // Bits 17-14: Excitation Current
            configWord |= (curr << 14);
            // Bits 13-12: Curve
            configWord |= (curve << 12);
        }

        // ============================================
        // ç™¼é€æŒ‡ä»¤
        // æ–°æ ¼å¼: CMD:SET_LTC <dev> <ch> <type> <config>
        // æ³¨æ„: config ä½¿ç”¨ Hex å‚³é€æ¯”è¼ƒå®‰å…¨
        // ============================================
        const configHex = configWord.toString(16).toUpperCase();
        
        // ç‚ºäº†ç›¸å®¹èˆŠç‰ˆï¼Œå¦‚æœ config ç‚º 0 (ä¾‹å¦‚ None)ï¼Œå¯ä»¥ä¸å‚³æˆ–å‚³ 0
        const cmd = `CMD:SET_LTC ${dev} ${ch} ${type} ${configHex}`;
        
        console.log("Sending Config:", cmd); // Debug ç”¨
        await sendStringCommand(cmd);
    }
	
   
    // [ä¿®æ­£ç‰ˆ] å›å‚³ { config: åŸºç¤è¨­å®š, data: è¼”åŠ©æ•¸æ“š, target: é è¦½å€¼ }
    function getLTCConfigWord(rowId) {
        const row = document.getElementById(rowId);
        if (!row) return { config: 0, data: 0, target: 0 };
        
        const type = parseInt(row.querySelector('.row-type-select').value);
        let config = 0; // å°æ‡‰ struct.sensor_config
        let data = 0;   // å°æ‡‰ struct.excitation_current æˆ– cold_junction_chan
        let target = 0; // é è¦½ç”¨çš„æœ€çµ‚ Chip å€¼

        // =================================================================
        // Case 1: Diode
        // Config: SE, 3-Read, Avg
        // Data: Excitation Current
        // =================================================================
        if (type === 28) { 
            // 1. Config (Bit 0-2) -> C Code: << 24
            if (row.querySelector('.chk-diode-se').checked) config |= (1 << 2);
            if (row.querySelector('.chk-diode-3r').checked) config |= (1 << 1);
            if (row.querySelector('.chk-diode-avg').checked) config |= (1 << 0);
            
            // 2. Data (Excitation Current) -> C Code: ç›´æ¥è³¦å€¼ (0~3)
            data = parseInt(row.querySelector('.sel-diode-curr').value);

            // 3. è¨ˆç®—é è¦½ Target
            // Config << 24
            target |= ((config & 0x07) << 24);
            // Current << 22 (Datasheetå®šç¾©)
            target |= ((data & 0x03) << 22);
        }
        
        // =================================================================
        // Case 2: Thermocouple
        // Config: SE, OC Det, OC Curr
        // Data: Cold Junction Channel
        // =================================================================
        else if (type >= 1 && type <= 9) { 
            // 1. Config (Bit 0-3) -> C Code: << 18
            // Bit 21 (SE) -> 21-18=3
            if (row.querySelector('.chk-tc-se').checked) config |= (1 << 3);
            // Bit 20 (OC Det) -> 20-18=2
            if (row.querySelector('.chk-tc-oc').checked) config |= (1 << 2);
            // Bit 18-19 (OC Curr) -> 18-18=0
            const ocCurr = parseInt(row.querySelector('.sel-tc-curr').value);
            config |= (ocCurr << 0);

            // 2. Data (Cold Junction Ch) -> C Code: ç›´æ¥è³¦å€¼ (0~20)
            data = parseInt(row.querySelector('.sel-tc-cj').value);

            // 3. è¨ˆç®—é è¦½ Target
            // Config << 18
            target |= (config << 18);
            // Cold Junction << 22 (Datasheetå®šç¾©)
            target |= (data << 22);
        }
        
        // =================================================================
        // Case 3: RTD
        // Config: All in one
        // Data: 0 (æˆ– Rsense Ch)
        // =================================================================
        else if (type >= 10 && type <= 18) {
            const wires = parseInt(row.querySelector('.sel-rtd-wires').value);
            const curr = parseInt(row.querySelector('.sel-rtd-curr').value);
            const curve = parseInt(row.querySelector('.sel-rtd-curve').value);

            config |= (wires << 20);
            config |= (curr << 14);
            config |= (curve << 12);
            
            target = config; // RTD é€šå¸¸æ²’æœ‰é¡å¤–ä½ç§»
            data = 0; // æš«æ™‚ç„¡è¼”åŠ©æ•¸æ“š
        }

        return { config: config, data: data, target: (target >>> 0) };
    }

	function updateConfigHexPreview(rowId) {
        const result = getLTCConfigWord(rowId);
        const hexSpan = document.getElementById(`hex-${rowId}`);
        
        if (hexSpan) {
            const configHex = '0x' + result.config.toString(16).toUpperCase();
            const dataHex = '0x' + result.data.toString(16).toUpperCase();
            const targetHex = '0x' + result.target.toString(16).toUpperCase().padStart(8, '0');
            
            hexSpan.innerHTML = `
                <div style="font-size:10px; color:#aaa;">CMD params:</div>
                <div><span class="hex-label">Cfg:</span>${configHex}</div>
                <div><span class="hex-label">Dat:</span>${dataHex}</div>
                <div style="border-top:1px solid #444; margin-top:2px; padding-top:2px;">
                    <span class="hex-label" style="color:#0f0;">Chip:</span>${targetHex}
                </div>
            `;
        }
    }

    async function setSingleLTCRow(rowId) {
        const row = document.getElementById(rowId);
        if (!row) return;

        const dev = row.querySelector('.row-dev-select').value;
        const ch = row.querySelector('.row-ch-select').value;
        const type = parseInt(row.querySelector('.row-type-select').value);

        // å–å¾—è¨ˆç®—çµæœ
        const result = getLTCConfigWord(rowId);
        
        // è½‰æˆ Hex å­—ä¸²
        const configHex = result.config.toString(16).toUpperCase();
        const dataHex = result.data.toString(16).toUpperCase();
        
        // [ä¿®æ”¹] æŒ‡ä»¤æ ¼å¼å¢åŠ ç¬¬äº”å€‹åƒæ•¸: Data
        // ä¾‹å¦‚: CMD:SET_LTC 1 5 28 7 1 (Device 1, Ch 5, Diode, Config=7, Curr=1)
        const cmd = `CMD:SET_LTC ${dev} ${ch} ${type} ${configHex} ${dataHex}`;
        
        console.log("Sending Config:", cmd);
        await sendStringCommand(cmd);
    }
	
	// 6. è¨­å®šå…¨éƒ¨ (Set All) - [å·²ä¿®æ­£] æ”¹ç‚ºå‘¼å« setSingleLTCRow ä»¥åŒ…å«é€²éšåƒæ•¸
    async function setAllLTCRows() {
        const rows = document.querySelectorAll('#ltcConfigRowsContainer .config-row');
        if (rows.length === 0) return;

        for (const row of rows) {
            // [ä¿®æ­£é‡é»]
            // åŸæœ¬æ˜¯æ‰‹å‹•çµ„å­—ä¸²: const cmd = `CMD:SET_LTC ${dev} ${ch} ${type}`;
            // ç¾åœ¨æ”¹ç‚º: ç›´æ¥å‘¼å« setSingleLTCRow(row.id)
            // é€™æ¨£å°±æœƒè‡ªå‹•å»æŠ“ checkbox ç‹€æ…‹ã€è¨ˆç®— Hex Config ä¸¦å‚³é€æ­£ç¢ºæŒ‡ä»¤
            
            await setSingleLTCRow(row.id);
            
            // ä¿æŒé–“éš”ï¼Œé¿å…å¡çˆ† USB
            await new Promise(r => setTimeout(r, 20)); 
        }

        // [ä¿®æ”¹é‡é»] è®€å– "è·³éç¢ºèª" çš„å‹¾é¸ç‹€æ…‹
        const chkSkip = document.getElementById('skipDisableConfirmLTC');
        const skipConfirm = chkSkip ? chkSkip.checked : false;

        // å¦‚æœ "æ²’æœ‰å‹¾é¸è·³é"ï¼Œæ‰é¡¯ç¤ºå®Œæˆæç¤º (Alert)
        if (!skipConfirm) {
            alert(`å·²ç™¼é€ ${rows.length} çµ„ LTC é…ç½®æŒ‡ä»¤ï¼`);
        }
    }
	
	// ã€æ–°å¢ã€‘é—œé–‰æ‰€æœ‰ LTC é€šé“
    async function disableAllLTCChannels() {
        if (!isConnected) {
            alert("è«‹å…ˆé€£ç·š (Connect)ï¼");
            return;
        }
        
        if (window.isBulkDisabling) return; 

        // 1. å–å¾—é¸é …ç‹€æ…‹
        // ä½¿ç”¨å®‰å…¨å¯«æ³•ï¼Œé˜²æ­¢æ‰¾ä¸åˆ°å…ƒç´ å ±éŒ¯
        const chkClear = document.getElementById('clearDataOnDisableLTC');
        const clearData = chkClear ? chkClear.checked : false;
        
        const chkSkip = document.getElementById('skipDisableConfirmLTC');
        const skipConfirm = chkSkip ? chkSkip.checked : false;

        // 2. ç¢ºèªè¦–çª—é‚è¼¯ (ä¿®æ­£ç‰ˆ)
        // å¦‚æœ "æ²’æœ‰å‹¾é¸è·³é" (skipConfirm ç‚º false)ï¼Œæ‰è·³å‡ºè©¢å•
        if (!skipConfirm) {
            if (!confirm("ç¢ºå®šè¦é—œé–‰æ‰€æœ‰ LTC2983 é€šé“å—ï¼Ÿ")) return;
        }

        window.isBulkDisabling = true; 

        try {
            const allKeys = Object.keys(globalData.channels);
            const ltcKeys = allKeys.filter(k => k.startsWith('LTC'));
            
            if (ltcKeys.length === 0) {
                // æ²’æœ‰é€šé“ä¹Ÿæ²’é—œä¿‚ï¼Œåªæ˜¯è§£é–ä¸¦è¿”å›
                window.isBulkDisabling = false;
                return;
            }

            for (const chKey of ltcKeys) {
                const parts = chKey.split('_');
                let dev = 1, ch = 1;
                
                if (parts.length === 3) {
                    dev = parts[1];
                    ch = parts[2];
                } else if (parts.length === 2) {
                    dev = 1; 
                    ch = parts[1];
                }

                await sendStringCommand(`CMD:SET_LTC ${dev} ${ch} 0`);
                
                if (clearData) {
                    delete globalData.channels[chKey];
                    hiddenChannels.delete(chKey);
                }
                
                await new Promise(r => setTimeout(r, 20));
            }
            
            updateChartWindow();
            
        } catch (error) {
            console.error("Disable All LTC Error:", error);
            alert("é—œé–‰é€šé“æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š" + error.message);
        } finally {
            window.isBulkDisabling = false; 
        }
    }
	
    // 7. æ‰¹é‡å¥—ç”¨ Type
    function applyBatchLTCType() {
        const val = document.getElementById('batchLtcTypeSelect').value;
        const selects = document.querySelectorAll('#ltcConfigRowsContainer .row-type-select');
        selects.forEach(s => s.value = val);
        saveLTCConfigRows();
    }
	

    window.toggleBox = function(elementId) {
        document.getElementById(elementId).classList.toggle('collapsed');
    }

    window.toggleManualInput = function() {
        const auto = document.getElementById('autoScale').checked;
        document.getElementById('manualInput').style.display = auto ? 'none' : 'inline-block';
        if(!auto) forceUpdateChart();
    }

    window.forceUpdateChart = function() { updateChartWindow(); }

    window.clearCharts = function() {
        globalData.labels = [];
        globalData.channels = {};
        globalSampleCount = 0;
        isAutoScroll = true;
        hiddenChannels.clear();
        lastReceivedData = [];
        const scrollBar = document.getElementById('historyScroll');
        scrollBar.value = 0;
        scrollBar.max = 0;
        updateScrollbarState();
        updateChartWindow();
        updateBarChart([]);
    }
	// ===========================================
    //   [æ–°å¢] è¨­å®šæª” åŒ¯å‡º / åŒ¯å…¥ åŠŸèƒ½
    // ===========================================

// 1. åŒ¯å‡ºè¨­å®š (å®Œæ•´ç‰ˆï¼šåŒ…å« LTC, TMP117, Anomaly, Colors, System)
    function exportSettings() {
        // ç¢ºä¿ç›®å‰çš„ UI è¨­å®šéƒ½å·²å„²å­˜åˆ° LocalStorage
        saveLTCConfigRows();
        saveConfigRows();     // TMP117
        saveAnomalyRules();
        saveBufferSettings();

        const settings = {
            version: "4.2", // å‡ç´šç‰ˆæœ¬è™Ÿ
            timestamp: new Date().toISOString(),
            
            // 1. LTC2983 è¨­å®š
            ltc_config: JSON.parse(localStorage.getItem('stm32_ltc_config_rows') || "[]"),
            
            // 2. TMP117 è¨­å®š
            tmp117_config: JSON.parse(localStorage.getItem('stm32_config_rows') || "[]"),
            
            // 3. ç•°å¸¸åµæ¸¬è¦å‰‡
            anomaly_config: JSON.parse(localStorage.getItem('stm32_anomaly_config') || "{}"),
            
            // 4. é€šé“é¡è‰²
            colors: JSON.parse(localStorage.getItem('stm32_channel_colors') || "{}"),
            
            // 5. ç³»çµ±åƒæ•¸ (é–“éš”ã€Bufferã€Logã€Stuck)
            system: {
                tx_interval: localStorage.getItem('stm32_tx_interval') || "1000",
                buffer_settings: JSON.parse(localStorage.getItem('stm32_buffer_settings') || "{}"),
                log_lines: localStorage.getItem('stm32_log_lines') || "100",
                stuck_threshold: localStorage.getItem('stm32_stuck_threshold') || "5"
            }
        };

        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(settings, null, 2));
        const downloadAnchor = document.createElement('a');
        downloadAnchor.setAttribute("href", dataStr);
        
        // æª”ååŠ ä¸Šæ™‚é–“æˆ³è¨˜
        const dateStr = new Date().toISOString().slice(0,19).replace(/:/g,"-");
        downloadAnchor.setAttribute("download", `STM32_Full_Config_${dateStr}.json`);
        
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
    }

    // 2. è§¸ç™¼åŒ¯å…¥ (é»æ“Šéš±è—çš„ input)
    function triggerImport() {
        document.getElementById('importFile').click();
    }

   // 3. åŸ·è¡ŒåŒ¯å…¥ (å®Œæ•´ç‰ˆ)
    function importSettings(input) {
        const file = input.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const settings = JSON.parse(e.target.result);
                
                if (!confirm("åŒ¯å…¥å°‡æœƒè¦†è“‹ç›®å‰æ‰€æœ‰çš„è¨­å®š (åŒ…å«é¡è‰²èˆ‡è¦å‰‡)ï¼Œç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ")) {
                    input.value = '';
                    return;
                }

                // --- 1. é‚„åŸ LTC2983 è¨­å®š ---
                if (settings.ltc_config) {
                    localStorage.setItem('stm32_ltc_config_rows', JSON.stringify(settings.ltc_config));
                    // æ¸…ç©ºç¾æœ‰å®¹å™¨ä¸¦é‡æ–°è¼‰å…¥
                    document.getElementById('ltcConfigRowsContainer').innerHTML = '';
                    loadLTCConfigRows(); 
                }

                // --- 2. é‚„åŸ TMP117 è¨­å®š ---
                if (settings.tmp117_config) {
                    localStorage.setItem('stm32_config_rows', JSON.stringify(settings.tmp117_config));
                    document.getElementById('configRowsContainer').innerHTML = '';
                    loadConfigRows();
                }

                // --- 3. é‚„åŸç•°å¸¸åµæ¸¬è¦å‰‡ ---
                if (settings.anomaly_config) {
                    localStorage.setItem('stm32_anomaly_config', JSON.stringify(settings.anomaly_config));
                    loadAnomalyRules();
                }

                // --- 4. é‚„åŸé¡è‰²è¨­å®š ---
                if (settings.colors) {
                    localStorage.setItem('stm32_channel_colors', JSON.stringify(settings.colors));
                    channelColors = settings.colors; // æ›´æ–°è¨˜æ†¶é«”è®Šæ•¸
                }

                // --- 5. é‚„åŸç³»çµ±åƒæ•¸ ---
                if (settings.system) {
                    if (settings.system.tx_interval) {
                        localStorage.setItem('stm32_tx_interval', settings.system.tx_interval);
                        document.getElementById('cfg_interval').value = settings.system.tx_interval;
                    }
                    if (settings.system.buffer_settings) {
                        localStorage.setItem('stm32_buffer_settings', JSON.stringify(settings.system.buffer_settings));
                        loadBufferSettings();
                    }
                    if (settings.system.log_lines) {
                        localStorage.setItem('stm32_log_lines', settings.system.log_lines);
                        loadLogSettings();
                    }
                    if (settings.system.stuck_threshold) {
                        localStorage.setItem('stm32_stuck_threshold', settings.system.stuck_threshold);
                        stuckThreshold = parseInt(settings.system.stuck_threshold);
                        const el = document.getElementById('stuckThresholdInput');
                        if (el) el.value = stuckThreshold;
                    }
                }

                alert("å®Œæ•´è¨­å®šåŒ¯å…¥æˆåŠŸï¼\n\næ³¨æ„ï¼šç¡¬é«”åƒæ•¸ (Set All) éœ€è¦æ‰‹å‹•é»æ“ŠæŒ‰éˆ•æ‰æœƒç™¼é€åˆ° STM32ã€‚");

            } catch (err) {
                console.error(err);
                alert("åŒ¯å…¥å¤±æ•—ï¼šæª”æ¡ˆæ ¼å¼éŒ¯èª¤æˆ–ææ¯€");
            }
            // æ¸…ç©º inputï¼Œç¢ºä¿ä¸‹æ¬¡é¸åŒå€‹æª”æ¡ˆä¹Ÿèƒ½è§¸ç™¼
            input.value = '';
        };
        reader.readAsText(file);
    }
	
	// ===========================================
    //   [æ•´åˆç‰ˆ] è‡ªå‹•å­˜æª”ç³»çµ± (CSV + Image)
    // ===========================================
    
    let autoSaveBuffer = [];
    let logDirHandle = null;

    // --- 1. è¨­å®šè®€å¯« ---
    function loadAutoSaveSettings() {
        const count = localStorage.getItem('stm32_auto_save_count');
        const csvEn = localStorage.getItem('stm32_auto_csv_enable');
        const imgEn = localStorage.getItem('stm32_auto_img_enable');

        if (count) document.getElementById('cfg_auto_save_count').value = count;
        if (csvEn === 'true') document.getElementById('cfg_auto_csv_enable').checked = true;
        if (imgEn === 'true') document.getElementById('cfg_auto_img_enable').checked = true;
        
        updateSaveProgressUI();
    }

    function saveAutoSaveSettings() {
        const count = document.getElementById('cfg_auto_save_count').value;
        const csvEn = document.getElementById('cfg_auto_csv_enable').checked;
        const imgEn = document.getElementById('cfg_auto_img_enable').checked;

        localStorage.setItem('stm32_auto_save_count', count);
        localStorage.setItem('stm32_auto_csv_enable', csvEn);
        localStorage.setItem('stm32_auto_img_enable', imgEn);
        
        // å¦‚æœå…©è€…éƒ½é—œé–‰ï¼Œæ¸…ç©º Buffer
        if (!csvEn && !imgEn && autoSaveBuffer.length > 0) {
            autoSaveBuffer = [];
            updateSaveProgressUI();
        }
    }

    // --- 2. æ ¸å¿ƒè§¸ç™¼ (å…¥å£) ---
    function handleAutoSave(timestamp, dataMap) {
        const csvEn = document.getElementById('cfg_auto_csv_enable').checked;
        const imgEn = document.getElementById('cfg_auto_img_enable').checked;

        if (!csvEn && !imgEn) return;

        const targetCount = parseInt(document.getElementById('cfg_auto_save_count').value) || 1000;

        // å­˜å…¥ Buffer
        let row = { Time: timestamp };
        Object.assign(row, dataMap);
        autoSaveBuffer.push(row);
        updateSaveProgressUI();

        // æª¢æŸ¥æ˜¯å¦é”æ¨™
        if (autoSaveBuffer.length >= targetCount) {
            performAutoSave(); // åŸ·è¡Œå­˜æª”
        }
    }

    function updateSaveProgressUI() {
        const el = document.getElementById('save_progress');
        if(el) {
            const target = document.getElementById('cfg_auto_save_count').value;
            el.innerText = `(${autoSaveBuffer.length}/${target})`;
        }
    }

    // --- 3. åŸ·è¡Œå­˜æª” (CSV & Image) ---
    async function performAutoSave() {
        const csvEn = document.getElementById('cfg_auto_csv_enable').checked;
        const imgEn = document.getElementById('cfg_auto_img_enable').checked;
        
        // å–å¾—ç•¶å‰æ™‚é–“åšæª”å
        const now = new Date();
        const fileTimeStr = now.getFullYear() +
                        ("0" + (now.getMonth() + 1)).slice(-2) +
                        ("0" + now.getDate()).slice(-2) + "_" +
                        ("0" + now.getHours()).slice(-2) +
                        ("0" + now.getMinutes()).slice(-2) +
                        ("0" + now.getSeconds()).slice(-2);

        // A. å„²å­˜ CSV
        if (csvEn && autoSaveBuffer.length > 0) {
            await saveCSV(fileTimeStr, [...autoSaveBuffer]); // å‚³å‰¯æœ¬
        }

        // B. å„²å­˜åœ–ç‰‡ (æˆªå–ç•¶ä¸‹åœ–è¡¨)
        if (imgEn) {
            await saveChartImage(fileTimeStr);
        }

        // C. æ¸…ç©º Buffer
        autoSaveBuffer = [];
        updateSaveProgressUI();
    }

    // --- 4. CSV å­˜æª”å¯¦ä½œ ---
    async function saveCSV(timeStr, buffer) {
        // ç”¢ç”Ÿ CSV å…§å®¹
        let headers = new Set();
        headers.add("Time");
        buffer.forEach(row => Object.keys(row).forEach(k => headers.add(k)));
        const headerArr = Array.from(headers);
        let csvContent = headerArr.join(",") + "\n";
        buffer.forEach(row => {
            csvContent += headerArr.map(h => row[h] === undefined ? "" : row[h]).join(",") + "\n";
        });

        const fileName = `STM32_Log_${timeStr}_(${buffer.length}).csv`;
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });

        await writeToFileSystem(fileName, blob);
    }

    // --- 5. åœ–ç‰‡å­˜æª”å¯¦ä½œ ---
    async function saveChartImage(timeStr) {
        // å–å¾— Chart Canvas
        const canvas = document.getElementById('historyChart'); 
        if (!canvas) return;

        // è½‰æˆ Blob (PNG)
        canvas.toBlob(async (blob) => {
            const fileName = `STM32_Chart_${timeStr}.png`;
            await writeToFileSystem(fileName, blob);
        }, 'image/png');
    }

    // --- 6. çµ±ä¸€å¯«å…¥ç³»çµ± (æ”¯æ´è³‡æ–™å¤¾ / ä¸‹è¼‰) ---
    async function writeToFileSystem(fileName, blob) {
        // æ¨¡å¼ 1: ç›´æ¥å¯«å…¥è³‡æ–™å¤¾
        if (logDirHandle) {
            try {
                const fileHandle = await logDirHandle.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(blob);
                await writable.close();
                console.log(`[Auto Save] Written: ${fileName}`);
                return;
            } catch (err) {
                console.error("Write failed:", err);
                // å¤±æ•—å‰‡è·Œè½è‡³ä¸‹è¼‰æ¨¡å¼
            }
        }

        // æ¨¡å¼ 2: å‚³çµ±ä¸‹è¼‰
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", fileName);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
  


	// ===========================================
    //   [é€²éš] æª”æ¡ˆç³»çµ±å­˜å– (File System Access)
    // ===========================================
    

	// [æœ€çµ‚ç‰ˆ] é¸æ“‡/é‡é€£ è³‡æ–™å¤¾å‡½å¼ (é‚è¼¯ä¿®æ­£ï¼šç¢ºå®š=é‡é€£ï¼Œå–æ¶ˆ=æ›æ–°)
    async function selectLogFolder() {
        if (!('showDirectoryPicker' in window)) {
            alert("ç€è¦½å™¨ä¸æ”¯æ´ï¼Œè«‹ä½¿ç”¨ Chrome/Edgeã€‚");
            return;
        }

        try {
            // A. æª¢æŸ¥æ˜¯å¦å·²æœ‰è¨˜æ†¶çš„è³‡æ–™å¤¾
            if (logDirHandle) {
                // è·³å‡ºç¢ºèªè¦–çª—
                // true (ç¢ºå®š) => é‡é€£
                // false (å–æ¶ˆ) => æ›æ–°
                const wantToReconnect = confirm(
                    `ç›®å‰è¨˜æ†¶çš„è³‡æ–™å¤¾ç‚ºï¼š\nğŸ“‚ ${logDirHandle.name}\n\n` +
                    `â— æŒ‰ä¸‹ã€Œç¢ºå®šã€ï¼šç¹¼çºŒä½¿ç”¨ (é‡é€£æ¬Šé™)\n` +
                    `â— æŒ‰ä¸‹ã€Œå–æ¶ˆã€ï¼šæ›´æ›å…¶ä»–è³‡æ–™å¤¾`
                );

                if (wantToReconnect) {
                    // --- ä½¿ç”¨è€…é¸æ“‡ã€Œé‡é€£ã€ ---
                    // æª¢æŸ¥æ¬Šé™
                    if ((await logDirHandle.queryPermission({ mode: 'readwrite' })) !== 'granted') {
                        const status = await logDirHandle.requestPermission({ mode: 'readwrite' });
                        if (status !== 'granted') {
                            // æ¬Šé™è¢«æ‹’ï¼Œè©¢å•æ˜¯å¦æ›æ–°
                            if(confirm("é‡é€£å¤±æ•— (æ¬Šé™è¢«æ‹’)ã€‚æ˜¯å¦ç›´æ¥é¸æ“‡æ–°è³‡æ–™å¤¾ï¼Ÿ")) {
                                logDirHandle = null; // æ¸…ç©ºï¼Œé€²å…¥ B æµç¨‹
                            } else {
                                return; // æ”¾æ£„æ“ä½œ
                            }
                        }
                    }
                } else {
                    // --- ä½¿ç”¨è€…é¸æ“‡ã€Œå–æ¶ˆã€(å³æ›æ–°) ---
                    logDirHandle = null; // æ¸…ç©ºèˆŠç´€éŒ„ï¼Œå¼·åˆ¶é€²å…¥ B æµç¨‹
                }
            }

            // B. å¦‚æœæ²’æœ‰ handle (æˆ–æ˜¯å‰›å‰›æŒ‰äº†å–æ¶ˆè¦æ›æ–°)ï¼Œå‰‡é–‹å•Ÿé¸æ“‡è¦–çª—
            if (!logDirHandle) {
                // é–‹å•Ÿç³»çµ±è¦–çª—é¸è³‡æ–™å¤¾
                logDirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                
                // â˜… é¸å¥½å¾Œï¼Œå­˜å…¥ IndexedDB æ›´æ–°è¨˜æ†¶
                await saveDirectoryHandle(logDirHandle);
            }

            // C. æ›´æ–°ä»‹é¢ç‹€æ…‹ (ç¢ºèªæœ€çµ‚æ¬Šé™)
            if ((await logDirHandle.queryPermission({ mode: 'readwrite' })) === 'granted') {
                const btn = document.getElementById('btn_select_folder');
                btn.style.backgroundColor = '#28a745';
                btn.style.color = 'white';
                btn.style.border = 'none';
                btn.innerText = `ğŸ“‚ å·²å°±ç·’: ${logDirHandle.name}`;
                
                // åªæœ‰åœ¨çœŸçš„ã€Œæ–°é¸ã€çš„æ™‚å€™æ‰è·³ Alert
                if (!window.isRestoring) { 
                    alert(`è³‡æ–™å¤¾ "${logDirHandle.name}" è¨­å®šæˆåŠŸï¼\nä¹‹å¾Œå°‡è‡ªå‹•å¯«å…¥æ­¤ä½ç½®ã€‚`);
                }
                window.isRestoring = false;
            }

        } catch (err) {
            // ä½¿ç”¨è€…åœ¨é¸æ“‡è¦–çª—æŒ‰å–æ¶ˆ (ä¸éœ€å ±éŒ¯)
            console.log("Folder selection cancelled:", err);
        }
    }
	// ===========================================
    //   [æ–°å¢] IndexedDB è³‡æ–™åº« (ç”¨æ–¼è¨˜æ†¶è³‡æ–™å¤¾)
    // ===========================================
    const DB_NAME = 'STM32_Logger_DB';
    const STORE_NAME = 'dir_handles';

    function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, 1);
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME);
                }
            };
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    async function saveDirectoryHandle(handle) {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        tx.objectStore(STORE_NAME).put(handle, 'log_folder');
    }

    async function getDirectoryHandle() {
        const db = await openDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readonly');
            const req = tx.objectStore(STORE_NAME).get('log_folder');
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
    }
	// [æ–°å¢] ç¶²é é–‹å•Ÿæ™‚ï¼Œå˜—è©¦è®€å–ä¸Šæ¬¡çš„è³‡æ–™å¤¾
    async function tryRestoreFolder() {
        try {
            const handle = await getDirectoryHandle();
            if (handle) {
                logDirHandle = handle;
                window.isRestoring = true; // æ¨™è¨˜ç‹€æ…‹ï¼Œé¿å…å½ˆå‡ºå¤šé¤˜è¦–çª—
                
                // æ›´æ–°æŒ‰éˆ•å¤–è§€ï¼Œæç¤ºä½¿ç”¨è€…é»æ“Š
                const btn = document.getElementById('btn_select_folder');
                btn.innerText = `ğŸ“‚ é‡é€£: ${handle.name}`; // é¡¯ç¤ºä¸Šæ¬¡çš„è³‡æ–™å¤¾åç¨±
                btn.title = "é»æ“Šæ­¤æŒ‰éˆ•ä»¥æ¢å¾©å°ä¸Šæ¬¡è³‡æ–™å¤¾çš„å¯«å…¥æ¬Šé™";
                btn.style.backgroundColor = '#ffc107'; // é»ƒè‰² (ç­‰å¾…ç¢ºèª)
                btn.style.color = 'black';
                btn.style.fontWeight = 'bold';
            }
        } catch (e) {
            console.log("æ²’æœ‰å„²å­˜çš„è³‡æ–™å¤¾ç´€éŒ„");
        }
    }
    // åˆå§‹åŒ–
    window.addEventListener('load', () => {
        loadAutoSaveSettings();
        if(typeof tryRestoreFolder === 'function') tryRestoreFolder();
    });

	
</script>

</body>
</html>